javascript:(function(){
'use strict';

/* design:
 - single state object holds cfg/env/abort/log/items/seen/groupBest/ui/lb/crawl
 - core pipeline: collect -> dedup -> render queue; UI is createShell/render/bind
 - abort/cleanup/finalize centralized; finalize is idempotent; UI cleanup separate
 - crawl is bounded, same-site, abortable; HTML/script/bg scans only when needed
*/
/* rev1.26:
 - preserve thumb state on dedupe merges when URL unchanged; avoid needless reloads
 - track __renderUrl per card and reload only when URL changes or thumb incomplete
*/
/* rev1.29:
 - iOS repaint nudge: temp transform/will-change/backface with rAF restore + one-shot extra nudge after reveal
 - treat decode-with-timeout dim0 as retry (thumb/lb) with dim0 retry log
 - iPhone thumb concurrency throttles by item count; reevaluated in thumbPump (optional throttle log)
*/
/* rev1.30:
 - add ultra-light MutationObserver to trigger DOM-only rescan with debounce/cooldown
 - rescan uses DOM extract only; no html/script/bg scans; adds single mo rescan log line
*/
/* rev1.32:
 - remove visibility hide/show repaint path to avoid visible blink during loading
 - keep iOS repaint nudge and add light throttles for progress/info text updates
*/
/* rev1.33:
 - add TikTok (TT) embed collection/filter support (link + iframe)
 - reduce thumb retry black flash by removing BLANK_GIF swap during retry
*/
/* rev1.34:
 - TikTok (TT) embed: Lightbox auto-load (no LOAD button), keep other embeds unchanged
*/
/* rev1.35:
 - reduce perceived LOADING flicker with delayed overlay show + fade-out hide
*/
/* rev1.36:
 - reduce scroll jank while thumbs are loading by pausing pump during scroll and debouncing fallback scans
*/
/* rev1.37:
 - defer heavy thumb UI updates during scroll and suppress fallback full scan when IO is available
*/
/* rev1.38:
 - skip fallback full scans when IO is active and debounce render-time filter/sort applies to reduce jank
*/
/* rev1.39:
 - reduce scroll jank by removing per-thumb rect reads and lightening iOS repaint nudge paths
*/
/* rev1.40:
 - reduce scroll-time jank by batching repaint nudges and avoiding persistent GPU layers on thumb images
*/
/* rev1.41:
 - make Lightbox embed loading fully automatic (no LOAD button) and harden YT/INSTA sandbox settings
 - add best-effort card thumbnails for YT embeds and videos with poster
*/
/* rev1.42:
 - add lightweight playable marker + type outline for video/embed cards (no extra DOM nodes)
 - harden YouTube URL detection/normalization for watch/shorts/live/embed/m.youtube/youtube-nocookie
*/
/* rev1.43:
 - big list mode: skip img.decode for thumbs to reduce iOS scroll jank
 - adaptive IO rootMargin for large item counts
 - defer info UI updates while scrolling; flush once on scroll resume
*/
/* rev1.44:
 - keep type colored frame visible even after thumbnail image loads (move frame from .thumb outline to .card::after overlay)
*/
/* rev1.45:
 - lock colored card frame on top in iOS compositing paths and add matching type-colored frame in Lightbox
*/
/* rev1.46:
 - add always-visible compact type icon badges on card thumbnails (X/TT/YT/IG/IM/? and video ▶)
 - keep existing behavior while preserving full type info via badge title/aria-label
*/
/* rev1.47:
 - collect direct video links from a[href] (.mp4/.webm/.mov/.m4v/.ogv) when not matched as embeds
*/
/* rev1.48:
 - stop crawl boost on filter/sort taps; add explicit "巡回+" chip to trigger boost on demand
*/
/* rev1.49:
 - harden Lightbox direct-video playback on iOS and show VIDEO FAIL hints with host/error details
*/
/* rev1.50:
 - prefer direct video playback by removing default Lightbox crossorigin on videos
*/
/* rev1.51:
 - show VIDEO FAIL details on badge (multiline), add tap-to-copy info, and log full details
*/
/* rev1.52:
 - keep VIDEO FAIL badge from being overwritten by NO THUMB and expand failure info
 - defer Lightbox direct video src/load until after append for iOS stability
 */
/* rev1.53:
 - add srcdoc fallback for video.twimg.com direct video failures with no-referrer context
 */
/* rev1.54:
 - show VIDEO FAIL badge only when final playback failure is confirmed
 */
/* rev1.55:
 - prioritize in-view cards during scroll (viewport-first enqueue + visible-only pump)
 - keep prefetch but lower scroll-time concurrency and skip thumb decode while scrolling
 */
/* rev1.56:
 - thumbs load while scrolling using IO in-view flag (no rect reads in scroll-time pump path)
 */
/* rev1.57:
 - thumbs load while scrolling using IO in-view flag + high-Hz detection tuned scroll-time concurrency
 */
/* rev1.58:
 - isolate in-view update behavior by fixing thumb IO rootMargin to 0px
 */
/* rev1.59:
 - remove thumb IO callback rect reads via entry.rootBounds fallback
 - batch thumbPump via rAF scheduling from enqueue path and optimize queue hot path
 */
/* rev1.60:
 - default-hide originally hidden media in panel, add hidden toggle chip, and add hidden label on cards
 */
/* rev1.61:
 - hard cleanup: detach visibility/scroll/resize handlers and disconnect thumb IO on close
 - unobserve cards before removing failed thumb cards
 */
/* rev1.62:
 - make thumb/lightbox img src checks robust against browser absolute-url normalization
 */
/* rev1.63:
 - skip non-HTML crawl responses early by Content-Type check before text/DOM parse
 */
/* rev1.64:
 - switch render queue and thumb UI queue to head-index pops (avoid shift() hot-path cost)
 */
/* rev1.65:
 - reduce thumb flicker by avoiding unconditional extra iOS repaint nudge
 - keep visible thumb during same-src reload/retry when possible
 */
/* rev1.66:
 - collect direct image links from a[href] and normalize resize/blogimg variants for dedup
 */
/* rev1.67:
 - prefer higher-quality image variants when dedup keys collide
 */
/* rev1.68:
 - normalize livedoor.sp.blogimg.jp host variants in dedup URL keys
 - refresh card meta dimensions after thumb metrics resolve
 */
/* rev1.69:
 - avoid needless thumb reload when dedup switches between equivalent image URL variants
 */
/* rev1.70:
 - defer thumb URL switch while loading and apply at most one post-load refresh
 */
/* rev1.71:
 - dedup image-tag URL candidates by canonical key and prioritize best-first order
 */
/* rev1.72:
 - reduce thumb flicker by disabling retry and softening watchdog thumb kick aggressiveness
 */
/* rev1.73:
 - add thumbnail-likeness scoring and route high-score candidates to existing noise-hide flow
 */
/* rev1.74:
 - treat <=100x100 images as thumbnail-hide candidates in thumbnail scoring
 */
/* rev1.75:
 - detect small thumbnail size hints from crop/resize URL patterns and enforce <=100x100 hide after load
 */
/* rev1.76:
 - add hidden-reason breakdown (info/log), duplicate-cluster detail badge, and score debug labels
 */
/* rev1.77:
 - detect embed URLs in anchor text when href points to a different asset URL
 */
/* rev1.78:
 - treat pbs.twimg.com/media ?format=jpg/png/... links as direct images
 - skip text-embed fallback when href is direct image/video to keep media lightbox behavior
 */
/* rev1.79:
 - keep direct-image LB path while adding INSTA hint styling (badge/frame) from anchor text links
 */
/* rev1.82:
 - split embed badge/frame gradients by site image colors (YT/X/TT/INSTA/IMGUR; VIDEO/OTHER unchanged)
 */
/* rev1.83:
 - re-apply lockPage on delayed-visible UI at 800ms check so non-LB buttons remain tappable
 */
/* rev1.84:
 - boost thumbnail-like score for small square same-origin related-article links
 - add +1 hint for 320x320-style URL size markers under related-square context
 */
/* rev1.85:
 - normalize crawl candidates so same-host http links are upgraded to https on https pages
 - keep same-origin crawl active for mixed-scheme next/prev links on custom-domain livedoor pages
 */
/* rev1.86:
 - prioritize entry next/prev links in crawl queue to avoid early limit exhaustion on noisy pages
 - dedupe crawl candidates by normalized URL while preserving priority order
 */
/* rev1.87:
 - pre-boost crawl limit on dense-link pages when image count is still low
 - add crawl pre-boost log to verify boosted start conditions
 */
/* rev1.88:
 - enable pager plan for custom-domain livedoor archive articles
 - infer max pager count from page-current text like 1/7 when only p=2 link is exposed
 */
/* rev1.89:
 - normalize imgur single-image URLs that include file extensions before building embed URLs
 - keep IMGUR openUrl canonicalized to extension-free image page URLs
 */
/* rev1.90:
 - treat direct image/video URLs found in link text as media candidates when href is a lite/article wrapper
 - preserve existing embed detection while adding text-media fallback for missed source links
 */
/* rev1.91:
 - harden non-LB UI input by forcing bg passthrough/panel foreground and resilient button defaults
 */
/* rev1.92:
 - route non-LB UI taps via click/pointerup/touchend with ghost-click guard for hostile click hooks
 */
/* rev1.93:
 - harden thumbnail tap path for LB open with touch/pointer fallback + ghost-click suppression
 */
/* rev1.94:
 - keep Lightbox above panel by fixing lb z-index for panel-front layout introduced in rev1.91
 */
/* rev1.95:
 - add tap-vs-drag threshold on thumbnail gestures to prevent LB opens while scrolling the grid
 */
/* rev1.96:
 - suppress synthetic click after touch/pointer end and treat scroll delta as moved to avoid accidental LB opens
 */
/* rev1.97:
 - restore thumbnail LB open trigger to rev1.92 click-only behavior while keeping rev1.94 LB z-index fix
 */
/* rev1.98:
 - add touchend capture fallback for thumb tap when click is blocked, with strict move/scroll guard to keep scroll-safe behavior
 */
/* rev1.99:
 - route LB control/backdrop taps via click/pointerup/touchend to avoid dead controls after first LB open
 */
/* rev1.100:
 - dedupe LB non-click tap events (touchend/pointerup) so Prev/Next advances exactly one item per tap
 */
/* rev1.101:
 - dedupe minkch image variants like ...12345s.jpg and ...12345.jpg into one canonical image key
 */

const SCRIPT_NAME = 'img view b64';
const SCRIPT_REV = '1.101';
const BLANK_GIF = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==';

const state = {
  cfg: {},
  env: {},
  abort: { reason: null, controllers: new Set(), aborted: false },
  log: { ring: [], max: 200 },
  items: {
    list: [],
    byId: new Map(),
    nextId: 1,
    errorCount: 0,
    noiseCount: 0,
    lastRenderLog: 0,
    renderQueue: [],
    renderQueueHead: 0,
    renderScheduled: false,
    filterSortTimer: 0
  },
  seen: { map: new Map(), order: [] },
  groupBest: new Map(),
  ui: {
    root: null,
    shadow: null,
    wrap: null,
    header: null,
    filterBar: null,
    sortBar: null,
    logBtn: null,
    grid: null,
    info: null,
    progress: null,
    locked: false,
    prevOverflow: '',
    prevBodyOverflow: '',
    progressLast: 0,
    progressLastAt: 0,
    progressLastText: '',
    progressLastPhase: '',
    progressThrottleTimer: 0,
    progressPendingPhase: '',
    progressPendingText: '',
    progressTimer: 0,
    infoTimer: 0,
    infoLastAt: 0,
    infoLastText: '',
    infoThrottleTimer: 0,
    infoPendingText: '',
    __infoDirty: false,
    lastAllTap: 0,
    boundVis: false,
    onVisibilityChange: null,
    onPageShow: null,
    onFocus: null,
    domSort: 'DEFAULT'
  },
  lb: {
    open: false,
    index: -1,
    list: [],
    currentId: null,
    overlay: null,
    frame: null,
    media: null,
    caption: null,
    openBtn: null,
    badge: null
  },
  thumb: {
    observer: null,
    queuePri: [],
    queue: [],
    queuePriHead: 0,
    queueHead: 0,
    queued: new Set(),
    inFlight: 0,
    paused: false,
    pausedByScroll: false,
    scrollPauseUntil: 0,
    scrollResumeTimer: 0,
    scrollEndScanTimer: 0,
    pumpScheduled: false,
    lastIoRootRect: null,
    uiQueueHead: 0,
    onScroll: null,
    onResize: null,
    max: 0
  },
  mo: {
    obs: null,
    t: 0,
    lastRun: 0,
    pending: false,
    dirty: false,
    lastReason: ''
  },
  wd: {
    t: 0,
    running: false,
    lastTick: 0,
    thumbLastProgressAt: 0,
    thumbLastProgressCount: 0,
    lbLastProgressAt: 0,
    lbLastToken: 0,
    thumbKickMap: new Map(),
    lbKickCount: 0
  },
  crawl: {
    queue: [],
    queueDedup: new Set(),
    visited: new Set(),
    inFlight: 0,
    limit: 0,
    allowUserBoost: false,
    boostedAuto: false,
    mode: '',
    pagerBase: '',
    pagerParam: '',
    token: 0,
    stop: false,
    started: false,
    done: false,
    timer: 0
  }
};

/* [00] bootstrap/guard/cleanup */
const ROOT_ID = '__fmp_root__';

function disconnectThumbObserver() {
  if (!state.thumb) return;
  if (state.thumb.observer) {
    try { state.thumb.observer.disconnect(); } catch (e) {}
    state.thumb.observer = null;
  }
}

function cleanupUi() {
  disconnectMutationObserver();
  stopWatchdog();
  disconnectThumbObserver();
  if (state.thumb) {
    const grid = state.ui ? state.ui.grid : null;
    if (grid && state.thumb.onScroll) {
      try { grid.removeEventListener('scroll', state.thumb.onScroll); } catch (e) {}
    }
    if (state.thumb.onResize) {
      try { window.removeEventListener('resize', state.thumb.onResize); } catch (e) {}
    }
    state.thumb.onScroll = null;
    state.thumb.onResize = null;
    if (state.thumb.scrollResumeTimer) {
      clearTimeout(state.thumb.scrollResumeTimer);
      state.thumb.scrollResumeTimer = 0;
    }
    if (state.thumb.scrollEndScanTimer) {
      clearTimeout(state.thumb.scrollEndScanTimer);
      state.thumb.scrollEndScanTimer = 0;
    }
    state.thumb.pausedByScroll = false;
    state.thumb.scrollPauseUntil = 0;
    if (state.thumb.repaintRaf) {
      cancelAnimationFrame(state.thumb.repaintRaf);
      state.thumb.repaintRaf = 0;
    }
    if (state.thumb.repaintSet) state.thumb.repaintSet.clear();
    if (state.thumb.uiQueue) state.thumb.uiQueue.length = 0;
    state.thumb.uiQueueHead = 0;
    state.thumb.scanNow = null;
    state.thumb.__inited = false;
  }
  if (state.items && state.items.renderQueue) {
    state.items.renderQueue.length = 0;
    state.items.renderQueueHead = 0;
    state.items.renderScheduled = false;
  }
  if (state.items && state.items.filterSortTimer) {
    clearTimeout(state.items.filterSortTimer);
    state.items.filterSortTimer = 0;
  }
  if (state.ui.progressThrottleTimer) {
    clearTimeout(state.ui.progressThrottleTimer);
    state.ui.progressThrottleTimer = 0;
  }
  if (state.ui.infoThrottleTimer) {
    clearTimeout(state.ui.infoThrottleTimer);
    state.ui.infoThrottleTimer = 0;
  }
  if (state.ui.progressTimer) {
    clearInterval(state.ui.progressTimer);
    state.ui.progressTimer = 0;
  }
  if (state.ui.boundVis) {
    if (state.ui.onVisibilityChange) {
      try { document.removeEventListener('visibilitychange', state.ui.onVisibilityChange); } catch (e) {}
    }
    if (state.ui.onPageShow) {
      try { window.removeEventListener('pageshow', state.ui.onPageShow); } catch (e) {}
    }
    if (state.ui.onFocus) {
      try { window.removeEventListener('focus', state.ui.onFocus); } catch (e) {}
    }
    state.ui.boundVis = false;
  }
  state.ui.onVisibilityChange = null;
  state.ui.onPageShow = null;
  state.ui.onFocus = null;
  unlockPage(state);
  if (state.ui.root && state.ui.root.parentNode) {
    state.ui.root.parentNode.removeChild(state.ui.root);
  }
  state.ui.root = null;
}

function guardAndCleanup() {
  try {
    const root = document.getElementById(ROOT_ID);
    const htmlLocked = document.documentElement && document.documentElement.style.overflow === 'hidden';
    const bodyLocked = document.body && document.body.style.overflow === 'hidden';
    const htmlMarked = document.documentElement && document.documentElement.dataset && document.documentElement.dataset.fmpLocked === '1';
    const bodyMarked = document.body && document.body.dataset && document.body.dataset.fmpLocked === '1';
    if (!root && (htmlLocked || bodyLocked) && (htmlMarked || bodyMarked)) {
      unlockPage(state);
    }
  } catch (e) {}
  try {
    if (window.__FMP_RUNNING__ && typeof window.__FMP_STOP_CRAWL__ === 'function') {
      window.__FMP_STOP_CRAWL__('restart');
    }
  } catch (e) {}
  const old = document.getElementById(ROOT_ID);
  if (old && old.parentNode) old.parentNode.removeChild(old);
  window.__FMP_SCRIPT_NAME__ = SCRIPT_NAME;
  window.__FMP_SCRIPT_REV__ = SCRIPT_REV;
  window.__FMP_RUNNING__ = true;
}

let finalizeOnce = false;
function finalize(status, detail) {
  if (finalizeOnce) return;
  finalizeOnce = true;
  window.__FMP_RUNNING__ = false;
  disconnectMutationObserver();
  stopWatchdog();
  updateProgress('idle', status);
  safeCompletion(status, detail || {});
}

/* [01] env/device判定 */
function detectHighHzOnce() {
  try {
    if (!state.env) return;
    state.env.isHighHz = false;
    if (typeof requestAnimationFrame !== 'function') return;

    const samples = [];
    const targetSamples = 24;
    let prevTs = 0;
    let done = false;

    const finish = function() {
      if (done) return;
      done = true;
      try {
        if (!state.env) return;
        if (!samples.length) {
          state.env.isHighHz = false;
          return;
        }
        const sorted = samples.slice().sort(function(a, b) { return a - b; });
        const mid = Math.floor(sorted.length / 2);
        const median = (sorted.length % 2)
          ? sorted[mid]
          : ((sorted[mid - 1] + sorted[mid]) / 2);
        state.env.isHighHz = median < 11;
      } catch (e) {
        try { if (state.env) state.env.isHighHz = false; } catch (e2) {}
      }
      try {
        if (state.thumb && !state.thumb.paused) thumbPump();
      } catch (e) {}
    };

    const step = function(ts) {
      try {
        if (prevTs > 0) {
          const dt = ts - prevTs;
          if (dt > 0 && dt < 1000) samples.push(dt);
        }
        prevTs = ts;
        if (samples.length >= targetSamples) {
          finish();
          return;
        }
        requestAnimationFrame(step);
      } catch (e) {
        finish();
      }
    };

    requestAnimationFrame(step);
  } catch (e) {
    try { if (state.env) state.env.isHighHz = false; } catch (e2) {}
  }
}

function initEnv() {
  const ua = navigator.userAgent || '';
  const isIOSLike = /iP(hone|ad|od)/.test(ua) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
  const minSide = Math.min(screen.width || 0, screen.height || 0);
  const isIPad = isIOSLike && (/(iPad)/.test(ua) || minSide >= 768);
  const isIPhone = isIOSLike && !isIPad;
  const vv = window.visualViewport || null;
  const vw = vv ? vv.width : (window.innerWidth || minSide);
  const isWide = vw >= 900;
  state.env = {
    ua: ua,
    isIOS: isIOSLike,
    isIPad: isIPad,
    isIPhone: isIPhone,
    vv: vv,
    isWide: isWide,
    isHighHz: false,
    thumbBoxPx: isWide ? 180 : 140,
    dpr: window.devicePixelRatio || 1,
    href: location.href,
    host: location.hostname,
    origin: location.origin
  };
  if (isIPhone) detectHighHzOnce();
}

/* [02] cfg */
function initCfg() {
  state.cfg = {
    minWidth: 120,
    minHeight: 120,
    minArea: 160 * 160,
    bgMinItems: 16,
    scriptMinItems: 18,
    htmlMinItems: 22,
    lazyScrollSteps: 4,
    lazyDelayMs: 140,
    maxBgChecks: 120,
    maxScriptCount: 30,
    maxScriptChars: 200000,
    maxHtmlChars: 300000,
    renderChunk: 24,
    thumbConcurrentIphone: 3,
    thumbConcurrentIpad: 4,
    thumbRootMarginPx: 900,
    thumbScrollPauseMs: 140,
    thumbScrollResumeMs: 160,
    thumbScrollEndScanMs: 220,
    thumbTimeoutMs: 20000,
    thumbRetryMax: 0,
    thumbRetryDelayMs: 350,
    decodeTimeoutMsThumb: 800,
    decodeTimeoutMsLb: 1200,
    moEnabled: true,
    moDebounceMs: 250,
    moCooldownMs: 800,
    moMaxMutations: 80,
    moObserveAttributes: true,
    moAttrFilter: ['src','srcset','data-src','data-srcset','href','style','class'],
    wdEnabled: true,
    wdTickMs: 1200,
    wdStallMsThumb: 9000,
    wdStallMsLb: 5500,
    wdMaxKickThumb: 1,
    wdMaxKickLb: 2,
    wdMinItemsForThrottle: 180,
    wdLog: true,
    crawlBaseLimit: 12,
    crawlBoost: 24,
    crawlBoostLimit: 36,
    crawlConcurrent: 2,
    crawlTimeoutMs: 8000,
    crawlMaxQueue: 200,
    crawlMaxNewLinksPerDoc: 24,
    crawlPreferSameOriginOnly: true,
    crawlArticleMaxPages: 30,
    progressStaleMs: 1500,
    embedHeight: 360,
    strictBodyOnly: true,
    noiseMinW: 80,
    noiseMinH: 48,
    noiseMinArea: 6000,
    noiseMaxAspect: 8.0,
    thumbLikeMinScore: 5,
    thumbSmallMaxW: 100,
    thumbSmallMaxH: 100,
    noiseHide: true,
    hiddenHide: true,
    debug: false,
    preconnectHosts: [
      'https://i.imgur.com',
      'https://imgur.com',
      'https://s.imgur.com',
      'https://platform.twitter.com',
      'https://pbs.twimg.com',
      'https://video.twimg.com',
      'https://www.instagram.com',
      'https://i.ytimg.com',
      'https://www.youtube.com'
    ],
    siteHints: {
      articleSelectors: ['article', 'main', '.article', '.post', '#article', '#main', '.entry', '.content', '.entry-content', '.post-content', '.article-body', '#content', '.contents', '.main', '.articleBody'],
      avoidSelectors: ['nav', 'header', 'footer', 'aside', 'noscript', '.nav', '.footer', '.header', '.share', '.sns', '.social', '.icon', '.logo', '.breadcrumb', '.pager']
    }
  };
  state.filter = { key: 'ALL', opts: {} };
  state.sort = 'DEFAULT';
}

/* [03] logger */
function initLogger() {
  state.log.push = function(level, msg) {
    const time = new Date().toISOString();
    const line = `[${time}] ${level}: ${String(msg)}`;
    state.log.ring.push(line);
    if (state.log.ring.length > state.log.max) state.log.ring.shift();
    if (state.cfg.debug) console.log(line);
  };
  state.log.copy = async function() {
    const ts = new Date().toISOString();
    const stats = collectVisibilityStats(80);
    const visible = stats.visible;
    const hidden = Math.max(0, state.items.list.length - visible);
    const reasonSummary = formatHideReasonCounts(stats.counts, 8);
    const summary = [
      '=== img view b64 log ===',
      'time: ' + ts,
      'href: ' + location.href,
      'host: ' + location.hostname,
      'items: ' + state.items.list.length,
      'visible: ' + visible,
      'hidden: ' + hidden,
      'error: ' + state.items.errorCount,
      'filter: ' + (state.filter && state.filter.key ? state.filter.key : ''),
      'sort: ' + state.sort,
      'hidden_reason: ' + (reasonSummary || '(none)')
    ].join('\n');
    const ring = state.log.ring.length ? state.log.ring.join('\n') : '(none)';
    const list = getVisibleItems(60);
    const listText = list.length ? list.map(function(u, i) { return (i + 1) + '. ' + u; }).join('\n') : '(none)';
    const reasonLines = getHideReasonCountLines(stats.counts, 20);
    const reasonText = reasonLines.length ? reasonLines.join('\n') : '(none)';
    const hiddenItems = getHiddenItemsWithReason(60);
    const hiddenText = hiddenItems.length ? hiddenItems.join('\n') : '(none)';
    const failed = getFailedItems(20);
    const failedText = failed.length ? failed.map(function(u, i) { return (i + 1) + '. ' + u; }).join('\n') : '(none)';
    const text = [
      summary,
      '',
      '[log]',
      ring,
      '',
      '[hidden reason counts]',
      reasonText,
      '',
      '[visible items]',
      listText,
      '',
      '[hidden items]',
      hiddenText,
      '',
      '[failed items]',
      failedText
    ].join('\n');
    let ok = false;
    try {
      ok = await copyText(text);
    } catch (e) {
      ok = false;
    }
    if (ok) {
      flashLogButton();
      setInfoTemp('コピー成功', 900);
    } else {
      setInfoTemp('共有/モーダルを使用', 1400);
    }
  };
}

/* [04] abort */
function makeController() {
  const c = new AbortController();
  state.abort.controllers.add(c);
  return c;
}

function abortAll(reason) {
  if (state.abort.aborted) return;
  state.abort.aborted = true;
  state.abort.reason = reason || 'abort';
  disconnectMutationObserver();
  stopWatchdog();
  state.crawl.stop = true;
  if (state.crawl.timer) {
    clearTimeout(state.crawl.timer);
    state.crawl.timer = 0;
  }
  state.log.push('abort', 'reason=' + state.abort.reason + ' visited=' + state.crawl.visited.size + ' inFlight=' + state.crawl.inFlight + ' errors=' + state.items.errorCount);
  state.abort.controllers.forEach(function(c) {
    try { c.abort(); } catch (e) {}
  });
  state.abort.controllers.clear();
  updateProgress('idle', 'abort');
}

/* [05] url/canon */
const IMG_EXT = /\.(png|jpe?g|gif|webp|avif|bmp)(\?|#|$)/i;
const VID_EXT = /\.(mp4|webm|mov|m4v|ogv)(\?|#|$)/i;

function hasExcludedWord(u) {
  if (!u) return false;
  const s = String(u).toLowerCase();
  const words = ['favicon', 'apple-touch-icon', 'sprite', 'icon', 'logo', 'avatar', 'emoji', 'badge', 'spinner', 'loading', 'pixel', 'spacer'];
  for (let i = 0; i < words.length; i += 1) {
    if (s.indexOf(words[i]) !== -1) return true;
  }
  return false;
}

function isImageUrl(u) {
  if (!u) return false;
  const s = String(u).trim();
  if (!s) return false;
  if (/^data:/i.test(s)) return false;
  if (hasExcludedWord(s)) return false;
  if (/\.svg(\?|#|$)/i.test(s)) return false;
  return IMG_EXT.test(s);
}

function isPbsMediaImageUrl(u) {
  if (!u) return false;
  let x;
  try { x = new URL(String(u), location.href); } catch (e) { return false; }
  if ((x.hostname || '').toLowerCase() !== 'pbs.twimg.com') return false;
  if (!/^\/media\/[^/?#]+/i.test(x.pathname || '')) return false;
  const fmt = (x.searchParams.get('format') || '').toLowerCase();
  return /^(jpe?g|png|gif|webp|avif|bmp)$/.test(fmt);
}

function isDirectImageUrl(u) {
  return isImageUrl(u) || isPbsMediaImageUrl(u);
}

function isImgTagCandidateUrl(u) {
  if (!u) return false;
  const s = String(u).trim();
  if (!s) return false;
  if (/^data:/i.test(s)) return false;
  if (hasExcludedWord(s)) return false;
  if (/\.svg(\?|#|$)/i.test(s)) return false;
  return /^https?:/i.test(s) || /^blob:/i.test(s);
}

function isVideoUrl(u) {
  return /^data:video\//i.test(u) || VID_EXT.test(u);
}

function stripSizeSuffix(path) {
  let p = path;
  p = p.replace(/-\d{2,4}x\d{2,4}(?=\.[a-z0-9]+$)/i, '');
  p = p.replace(/-(s|m|t)(?=\.[a-z0-9]+$)/i, '');
  p = p.replace(/@2x(?=\.[a-z0-9]+$)/i, '');
  p = p.replace(/\._[A-Z0-9,-]+_(?=\.[a-z0-9]+$)/i, '');
  return p;
}

function normalizeUrl(raw, base) {
  if (!raw) return null;
  const s = String(raw).trim();
  if (!s) return null;
  if (s.startsWith('data:') || s.startsWith('blob:')) {
    const key = s.slice(0, 64) + ':' + s.length;
    return { abs: s, canon: s, groupKey: key, host: '' };
  }
  let u;
  try {
    u = new URL(s, base || location.href);
  } catch (e) {
    return null;
  }
  const unwrapKeys = ['url', 'u', 'img', 'image', 'media'];
  let unwrapped = '';
  for (let i = 0; i < unwrapKeys.length; i += 1) {
    const key = unwrapKeys[i];
    const rawVal = u.searchParams.get(key);
    if (!rawVal) continue;
    const direct = rawVal.trim();
    if (/^https?:/i.test(direct)) { unwrapped = direct; break; }
    try {
      const decoded = decodeURIComponent(direct);
      if (/^https?:/i.test(decoded)) { unwrapped = decoded; break; }
    } catch (e) {}
  }
  if (!unwrapped) {
    const hostNow = (u.hostname || '').toLowerCase();
    if (/^resize\.blogsys\.jp$/.test(hostNow)) {
      const joined = String((u.pathname || '') + (u.search || ''));
      let m = /(https?:\/\/.+)$/i.exec(joined);
      if (!m) {
        try {
          const decodedJoined = decodeURIComponent(joined);
          m = /(https?:\/\/.+)$/i.exec(decodedJoined);
        } catch (e) {}
      }
      if (m && m[1]) unwrapped = m[1];
    }
  }
  if (unwrapped) {
    try {
      u = new URL(unwrapped, base || location.href);
    } catch (e) {}
  }
  if (!/^https?:$/.test(u.protocol)) return null;
  u.hash = '';
  let host = u.hostname.toLowerCase();
  if (host === 'livedoor.sp.blogimg.jp') {
    host = 'livedoor.blogimg.jp';
    u.hostname = host;
  } else if (host.startsWith('sp.')) {
    host = host.replace(/^sp\./, '');
    u.hostname = host;
  }
  let path = u.pathname;
  if (/blogimg/.test(host)) {
    path = path.replace(/\/_thumbs?\//, '/');
    path = path.replace(/\/s\//, '/');
    path = path.replace(/\/resize\/\d+x\d+\//i, '/');
    path = path.replace(/\/thumbs?\/\d+x\d+\//i, '/');
  }
  path = stripSizeSuffix(path);
  u.pathname = path;

  const params = new URLSearchParams(u.search);
  const trackKeys = ['utm_source', 'utm_medium', 'utm_campaign', 'utm_term', 'utm_content', 'fbclid', 'gclid', 'igshid', 'ref', 'spm', '_t'];
  trackKeys.forEach(function(k) { params.delete(k); });

  const sizeKeys = ['w', 'h', 'width', 'height', 'resize', 'fit', 'quality', 'q', 'auto', 'crop', 'dpr'];
  const canonParams = new URLSearchParams();
  params.forEach(function(v, k) {
    if (sizeKeys.indexOf(k) === -1) canonParams.set(k, v);
  });

  const groupParams = new URLSearchParams();
  params.forEach(function(v, k) {
    if (['id', 'photo', 'photo_id', 'image', 'img', 'media', 'v'].indexOf(k) !== -1) {
      groupParams.set(k, v);
    }
  });

  u.search = canonParams.toString() ? '?' + canonParams.toString() : '';
  const canon = u.toString();
  const hasExt = /\.(png|jpe?g|gif|webp|avif|bmp|mp4|webm|mov|m4v)$/i.test(path);
  const groupKey = host + path + (hasExt ? '' : (groupParams.toString() ? '?' + groupParams.toString() : ''));
  return { abs: u.toString(), canon: canon, groupKey: groupKey, host: host };
}

function isLivedoorArticle(url) {
  try {
    const u = new URL(url, location.href);
    if (!/\/archives\/\d+\.html$/i.test(u.pathname || '')) return false;
    const host = u.hostname.toLowerCase();
    if (host === 'blog.livedoor.jp') return true;
    return host === location.hostname.toLowerCase();
  } catch (e) {
    return false;
  }
}

function computePageLabel(url) {
  try {
    const u = new URL(url, location.href);
    const p = u.searchParams.get('p') || u.searchParams.get('page');
    const num = p ? parseInt(p, 10) : 1;
    if (isLivedoorArticle(u.toString())) return 'P' + (num > 0 ? num : 1);
    if (p && num > 0) return 'P' + num;
  } catch (e) {}
  return 'P1';
}

function canonicalMediaKey(absUrl, kind) {
  if (!absUrl) return '';
  if (absUrl.startsWith('data:') || absUrl.startsWith('blob:')) return absUrl;
  let u;
  try {
    u = new URL(absUrl, location.href);
  } catch (e) {
    return absUrl;
  }
  u.hash = '';
  let host = u.hostname.toLowerCase();
  if (/^livedoor\.\d+\.blogimg\.jp$/.test(host) || host === 'livedoor.sp.blogimg.jp') {
    host = 'livedoor.blogimg.jp';
    u.hostname = host;
  }
  if (host === 'pbs.twimg.com') {
    return u.origin + u.pathname;
  }
  if (host === 'i.imgur.com') {
    const p = u.pathname.replace(/([a-z0-9])([sbtmlh])(\.[a-z0-9]+)$/i, '$1$3');
    u.pathname = p;
  }
  if (host === 'imgs.minkch.com') {
    u.pathname = (u.pathname || '').replace(/^(\/imgs\/(?:d)?\d{8,14}\/\d+)([smt])(\.[a-z0-9]+)$/i, '$1$3');
  }
  if (/blogimg\.jp$/.test(host)) {
    let p = u.pathname || '';
    p = p.replace(/\/_thumbs?\//, '/');
    p = p.replace(/\/s\//, '/');
    p = p.replace(/\/resize\/\d+x\d+\//i, '/');
    p = p.replace(/\/thumbs?\/\d+x\d+\//i, '/');
    p = stripSizeSuffix(p);
    u.pathname = p;
  }
  const params = new URLSearchParams(u.search);
  const dropExact = ['fbclid', 'gclid', 'ref', 'spm', 'mc_cid', 'mc_eid'];
  const dropSize = ['w', 'h', 'width', 'height', 'resize', 'fit', 'quality', 'q', 'dpr', 'auto', 'crop', 'name', 'sz'];
  const next = new URLSearchParams();
  params.forEach(function(v, k) {
    const key = k.toLowerCase();
    if (key.startsWith('utm_')) return;
    if (dropExact.indexOf(key) !== -1) return;
    if (dropSize.indexOf(key) !== -1) return;
    next.set(k, v);
  });
  u.search = next.toString() ? '?' + next.toString() : '';
  return u.origin + u.pathname + u.search;
}

function pickBestFromSrcset(srcset) {
  if (!srcset) return '';
  const parts = srcset.split(',');
  let bestUrl = '';
  let bestScore = -1;
  parts.forEach(function(part) {
    const seg = part.trim().split(/\s+/);
    if (!seg[0]) return;
    let score = 1;
    if (seg[1]) {
      if (seg[1].endsWith('w')) score = parseInt(seg[1], 10) || 1;
      if (seg[1].endsWith('x')) score = (parseFloat(seg[1]) || 1) * 1000;
    }
    if (score > bestScore) {
      bestScore = score;
      bestUrl = seg[0];
    }
  });
  return bestUrl;
}

/* [06] score/filter */
function scoreItem(item) {
  const area = item.width && item.height ? item.width * item.height : 0;
  let score = Math.log(area + 1);
  if (item.kind === 'video') score += 2;
  if (item.scope === 'body') score += 1;
  if (item.source === 'crawl') score += 0.5;
  if (/\.avif$/i.test(item.url)) score += 0.2;
  item.area = area;
  return score;
}

function imageVariantQuality(url) {
  if (!url) return 0;
  let score = 0;
  try {
    const u = new URL(String(url), location.href);
    const host = (u.hostname || '').toLowerCase();
    const path = (u.pathname || '').toLowerCase();
    if (/^resize\.blogsys\.jp$/.test(host)) score -= 30;
    const sizeTag = /-([smt])(?=\.[a-z0-9]+$)/i.exec(path);
    if (!sizeTag) score += 30;
    else if (sizeTag[1].toLowerCase() === 'm') score += 20;
    else if (sizeTag[1].toLowerCase() === 's') score += 10;
    else score += 5;
    const dimsInPath = /-(\d{2,4})x(\d{2,4})(?=\.[a-z0-9]+$)/i.exec(path);
    if (dimsInPath) {
      const dw = parseInt(dimsInPath[1] || '0', 10) || 0;
      const dh = parseInt(dimsInPath[2] || '0', 10) || 0;
      if (dw && dh) score += Math.min((dw * dh) / 50000, 20);
    }
    const params = new URLSearchParams(u.search);
    const qw = parseInt(params.get('w') || params.get('width') || '0', 10) || 0;
    const qh = parseInt(params.get('h') || params.get('height') || '0', 10) || 0;
    if (qw && qh) score += Math.min((qw * qh) / 50000, 20);
    if (qw || qh) score -= 6;
  } catch (e) {
    const s = String(url).toLowerCase();
    const sizeTag = /-([smt])(?=\.[a-z0-9]+($|[?#]))/i.exec(s);
    if (!sizeTag) score += 30;
    else if (sizeTag[1].toLowerCase() === 'm') score += 20;
    else if (sizeTag[1].toLowerCase() === 's') score += 10;
    else score += 5;
  }
  return score;
}

function imageQualityScore(item) {
  if (!item || item.kind !== 'img') return -999999;
  let best = -999999;
  const refs = [item.openUrl, item.rawUrl, item.abs, item.url];
  refs.forEach(function(u) {
    const q = imageVariantQuality(u);
    if (q > best) best = q;
  });
  if (item.width && item.height) {
    best += Math.min((item.width * item.height) / 80000, 10);
  }
  return best;
}

function isHigherQualityImageCandidate(candidate, existing) {
  if (!candidate || !existing) return false;
  if (candidate.kind !== 'img' || existing.kind !== 'img') return false;
  const q1 = imageQualityScore(candidate);
  const q2 = imageQualityScore(existing);
  if (q1 !== q2) return q1 > q2;
  return String(candidate.openUrl || '').length > String(existing.openUrl || '').length;
}

function passesSize(item) {
  if (!item.width || !item.height) return true;
  if (item.width < state.cfg.minWidth || item.height < state.cfg.minHeight) return false;
  if (item.width * item.height < state.cfg.minArea) return false;
  return true;
}

function passesFilter(item) {
  const key = state.filter.key || 'ALL';
  if (key === 'ALL') return true;
  if (key === 'BODY') return item.scope === 'body';
  if (key === 'IMG') return item.kind === 'img';
  if (key === 'VIDEO') return item.kind === 'video';
  if (key === 'X') return item.kind === 'embed' && item.embedType === 'X';
  if (key === 'INSTA') return item.embedType === 'INSTA';
  if (key === 'IMGUR') return item.kind === 'embed' && item.embedType === 'IMGUR';
  if (key === 'YT') return item.kind === 'embed' && item.embedType === 'YT';
  if (key === 'TT') return item.kind === 'embed' && item.embedType === 'TT';
  return true;
}

function applyFilterSort() {
  if (!state.ui.grid) return;
  const list = state.items.list;
  list.forEach(function(it) {
    const hideNoise = state.cfg.noiseHide && it.__isNoise;
    const hideHidden = state.cfg.hiddenHide && it.__allHidden;
    const failed = !!it.__failed;
    const show = passesFilter(it) && !hideNoise && !it.__hashDup && !failed && !hideHidden;
    it.__hideReason = show ? '' : getHideReasonCode(it);
    const card = it.card;
    if (card) {
      if (failed) {
        if (card.parentNode) card.parentNode.removeChild(card);
      } else {
        card.classList.toggle('is-hidden', !show);
      }
    }
  });
  const prevSort = state.ui.domSort || 'DEFAULT';
  const needReorder = (state.sort === 'SIZE') || (prevSort !== state.sort);
  if (needReorder) {
    const items = list.slice();
    if (state.sort === 'SIZE') {
      items.sort(function(a, b) {
        if (b.area !== a.area) return b.area - a.area;
        return a.index - b.index;
      });
    } else {
      items.sort(function(a, b) { return a.index - b.index; });
    }
    const frag = document.createDocumentFragment();
    items.forEach(function(it) {
      if (it.card && !it.__failed) frag.appendChild(it.card);
    });
    state.ui.grid.appendChild(frag);
    state.ui.domSort = state.sort;
  }
  applyErrorVis();
  updateInfo();
  updateChipUI();
  if (state.thumb && !state.thumb.observer && typeof state.thumb.scanNow === 'function') state.thumb.scanNow();
}

function updateChipUI() {
  if (!state.ui.filterBar || !state.ui.sortBar) return;
  const f = state.filter.key;
  const s = state.sort;
  Array.from(state.ui.filterBar.querySelectorAll('[data-filter]')).forEach(function(btn) {
    btn.classList.toggle('active', btn.getAttribute('data-filter') === f);
  });
  const boostBtn = state.ui.filterBar.querySelector('[data-action="boost-crawl"]');
  if (boostBtn) {
    boostBtn.classList.toggle('active', !!state.crawl.allowUserBoost);
  }
  const hiddenBtn = state.ui.filterBar.querySelector('[data-action="toggle-hidden"]');
  if (hiddenBtn) {
    hiddenBtn.classList.toggle('active', !state.cfg.hiddenHide);
  }
  Array.from(state.ui.sortBar.querySelectorAll('[data-sort]')).forEach(function(btn) {
    btn.classList.toggle('active', btn.getAttribute('data-sort') === s);
  });
}

function setFilter(key, opts) {
  state.filter = { key: key, opts: opts || {} };
  window.__FMP_FILTER__ = state.filter;
  applyFilterSort();
}

function setSort(key) {
  state.sort = key || 'DEFAULT';
  window.__FMP_SORT__ = state.sort;
  applyFilterSort();
}

/* [07] collect */
function inBodyScope(el) {
  if (!el || !el.closest) return false;
  const sel = state.cfg.siteHints.articleSelectors.join(',');
  if (!sel) return false;
  return !!el.closest(sel);
}

function inAvoidScope(el) {
  if (!el || !el.closest) return false;
  const sel = state.cfg.siteHints.avoidSelectors.join(',');
  if (!sel) return false;
  return !!el.closest(sel);
}

function getImgSize(img) {
  const w = img.naturalWidth || parseInt(img.getAttribute('width') || 0, 10) || 0;
  const h = img.naturalHeight || parseInt(img.getAttribute('height') || 0, 10) || 0;
  return { w: w, h: h };
}

function hasInlineHiddenStyle(styleText) {
  if (!styleText) return false;
  const s = String(styleText).toLowerCase();
  if (!s) return false;
  if (/(^|;)\s*display\s*:\s*none(\s*!important)?\s*(;|$)/.test(s)) return true;
  if (/(^|;)\s*visibility\s*:\s*(hidden|collapse)(\s*!important)?\s*(;|$)/.test(s)) return true;
  return false;
}

function isOriginallyHidden(el) {
  if (!el || el.nodeType !== 1) return false;
  const useComputed = !!el.isConnected;
  let cur = el;
  let depth = 0;
  while (cur && cur.nodeType === 1 && depth < 18) {
    if (cur.hasAttribute && cur.hasAttribute('hidden')) return true;
    if (cur.getAttribute) {
      const aria = (cur.getAttribute('aria-hidden') || '').toLowerCase();
      if (aria === 'true') return true;
      if (hasInlineHiddenStyle(cur.getAttribute('style'))) return true;
    }
    if (cur.tagName && cur.tagName.toUpperCase() === 'DETAILS' && !(cur.hasAttribute && cur.hasAttribute('open'))) {
      return true;
    }
    if (useComputed) {
      try {
        const style = getComputedStyle(cur);
        if (style && (style.display === 'none' || style.visibility === 'hidden' || style.visibility === 'collapse')) {
          return true;
        }
      } catch (e) {}
    }
    cur = cur.parentElement;
    depth += 1;
  }
  return false;
}

function scoreThumbnailLike(el, meta, absUrl) {
  if (!el || el.nodeType !== 1) return 0;
  const w = (meta && meta.width) ? meta.width : 0;
  const h = (meta && meta.height) ? meta.height : 0;
  let score = 0;

  if (w && h) {
    const sw = state.cfg.thumbSmallMaxW || 0;
    const sh = state.cfg.thumbSmallMaxH || 0;
    if (sw > 0 && sh > 0 && w <= sw && h <= sh) {
      score += (state.cfg.thumbLikeMinScore || 5);
    }
    const area = w * h;
    const aspect = Math.max(w / h, h / w);
    if (area <= 140 * 140) score += 2;
    else if (area <= 320 * 240) score += 1;
    if (aspect >= 1.2 && aspect <= 2.2) score += 1;
  } else {
    score += 1;
  }

  if (!inBodyScope(el)) score += 2;
  if (inAvoidScope(el)) score += 2;

  const cls = String((el.className || '') + ' ' + (el.id || '')).toLowerCase();
  if (/(thumb|thumbnail|related|ranking|recommend|popular|pickup|sidebar|widget|pager|list)/.test(cls)) score += 1;

  let anchor = null;
  let anchorHref = '';
  let relatedArticleSquare = false;
  if (el.tagName && el.tagName.toUpperCase() === 'A') anchor = el;
  else if (el.closest) anchor = el.closest('a[href]');
  if (anchor) {
    const href = (anchor.getAttribute('href') || '').trim();
    anchorHref = href;
    if (href) {
      if (!isImageUrl(href) && !isVideoUrl(href)) score += 1;
      if (/\/archives\/\d+|\.html(?:$|[?#])|\/(entry|article|post|news)\//i.test(href)) score += 2;
    }
  }
  if (w && h && anchorHref) {
    const squareishSmall = w <= 340 && h <= 340 && Math.abs(w - h) <= 24;
    if (squareishSmall) {
      try {
        const linkUrl = new URL(anchorHref, location.href);
        const nonMediaLink = !isImageUrl(anchorHref) && !isVideoUrl(anchorHref);
        const sameOrigin = linkUrl.origin === location.origin;
        const linkPath = (linkUrl.pathname || '/').replace(/\/+$/, '') || '/';
        const pagePath = (location.pathname || '/').replace(/\/+$/, '') || '/';
        const samePath = linkPath === pagePath;
        if (sameOrigin && samePath === false && nonMediaLink) {
          relatedArticleSquare = true;
          score += 4;
          if (/(related|recommend|ranking|pickup|popular|list)/.test(cls)) score += 1;
        }
      } catch (e) {}
    }
  }

  const u = String(absUrl || '').toLowerCase();
  const sw = state.cfg.thumbSmallMaxW || 0;
  const sh = state.cfg.thumbSmallMaxH || 0;
  let hintedW = 0;
  let hintedH = 0;
  const cropHint = /\/(?:crop\d*|resize|thumbs?)\/(\d{2,4})x(\d{2,4})(?:\/|$)/i.exec(u);
  if (cropHint) {
    hintedW = parseInt(cropHint[1] || '0', 10) || 0;
    hintedH = parseInt(cropHint[2] || '0', 10) || 0;
  } else {
    try {
      const pu = new URL(String(absUrl || ''), location.href);
      hintedW = parseInt(pu.searchParams.get('w') || pu.searchParams.get('width') || '0', 10) || 0;
      hintedH = parseInt(pu.searchParams.get('h') || pu.searchParams.get('height') || '0', 10) || 0;
    } catch (e) {}
  }
  if (sw > 0 && sh > 0 && hintedW && hintedH && hintedW <= sw && hintedH <= sh) {
    score += (state.cfg.thumbLikeMinScore || 5);
  }
  const hasSquare320PathHint = /(?:^|[\/_-])(?:3[01]\d|320)x(?:3[01]\d|320)(?:$|[\/_.\-?&#])/.test(u);
  const hasSquare320QueryHint = /[?&](?:w|width)=(?:3[01]\d|320)(?:[&#]|$)/.test(u) &&
    /[?&](?:h|height)=(?:3[01]\d|320)(?:[&#]|$)/.test(u);
  if (relatedArticleSquare && (hasSquare320PathHint || hasSquare320QueryHint)) score += 1;
  if (/(thumb|thumbnail|small|\/s\/|_thumb|\/resize\/\d+x\d+|[?&](w|h|width|height)=\d+)/.test(u)) score += 1;

  return score;
}

function collectImageUrls(img) {
  const urls = [];
  const seenCanon = new Set();
  function add(u) {
    if (!u) return;
    const s = String(u).trim();
    if (!s) return;
    if (!isImgTagCandidateUrl(s)) return;
    const canon = canonicalMediaKey(s, 'img') || s;
    if (seenCanon.has(canon)) return;
    seenCanon.add(canon);
    urls.push(s);
  }
  const srcset = img.getAttribute('srcset') || img.getAttribute('data-srcset');
  const best = pickBestFromSrcset(srcset);
  add(best);
  add(img.currentSrc);
  add(img.getAttribute('data-original'));
  add(img.getAttribute('data-src'));
  add(img.getAttribute('data-lazy'));
  add(img.src);
  return urls;
}

function findFirstHttpUrlInText(text) {
  if (!text) return '';
  const m = /https?:\/\/[^\s"'<>]+/i.exec(String(text));
  return m ? m[0] : '';
}

function extractFromDocument(doc, source, baseUrl) {
  const items = [];
  const strictBody = !!state.cfg.strictBodyOnly;
  const imgs = Array.from(doc.querySelectorAll('img'));
  imgs.forEach(function(img) {
    if (strictBody && !inBodyScope(img)) return;
    if (inAvoidScope(img)) return;
    const urls = collectImageUrls(img);
    if (!urls.length) return;
    const size = getImgSize(img);
    const scope = inBodyScope(img) ? 'body' : '';
    const origHidden = isOriginallyHidden(img);
    urls.forEach(function(u) {
      if (!isImgTagCandidateUrl(u)) return;
      items.push(makeItem('img', u, {
        width: size.w,
        height: size.h,
        scope: scope,
        origHidden: origHidden,
        source: source,
        openUrl: u,
        el: img
      }, baseUrl));
    });
  });

  const videos = Array.from(doc.querySelectorAll('video'));
  videos.forEach(function(video) {
    if (strictBody && !inBodyScope(video)) return;
    if (inAvoidScope(video)) return;
    const scope = inBodyScope(video) ? 'body' : '';
    const origHidden = isOriginallyHidden(video);
    const vsrcs = [];
    if (video.currentSrc) vsrcs.push(video.currentSrc);
    if (video.src) vsrcs.push(video.src);
    Array.from(video.querySelectorAll('source')).forEach(function(s) {
      if (s.src) vsrcs.push(s.src);
    });
    vsrcs.forEach(function(u) {
      if (!isVideoUrl(u)) return;
      items.push(makeItem('video', u, {
        width: parseInt(video.getAttribute('width') || 0, 10) || 0,
        height: parseInt(video.getAttribute('height') || 0, 10) || 0,
        scope: scope,
        origHidden: origHidden,
        poster: video.getAttribute('poster') || '',
        source: source,
        openUrl: u,
        el: video
      }, baseUrl));
    });
  });

  const links = Array.from(doc.querySelectorAll('a[href]'));
  links.forEach(function(a) {
    if (strictBody && !inBodyScope(a)) return;
    if (inAvoidScope(a)) return;
    const href = a.getAttribute('href');
    if (!href || href.startsWith('#')) return;
    const abs = normalizeUrl(href, baseUrl || location.href);
    if (!abs) return;
    const scope = inBodyScope(a) ? 'body' : '';
    const origHidden = isOriginallyHidden(a);
    const linkImg = a.querySelector ? a.querySelector('img') : null;
    const linkSize = linkImg ? getImgSize(linkImg) : { w: 0, h: 0 };
    const embedFromHref = getEmbedInfo(abs.abs);
    const hrefIsDirectImage = isDirectImageUrl(abs.abs);
    const hrefIsDirectVideo = isVideoUrl(abs.abs);
    const hrefIsDirectMedia = hrefIsDirectImage || hrefIsDirectVideo;
    const textUrl = findFirstHttpUrlInText(a.textContent || '');
    let textAbs = null;
    let textEmbed = null;
    let textIsDirectImage = false;
    let textIsDirectVideo = false;
    if (textUrl) {
      textAbs = normalizeUrl(textUrl, baseUrl || location.href);
      if (textAbs) {
        textEmbed = getEmbedInfo(textAbs.abs);
        textIsDirectImage = isDirectImageUrl(textAbs.abs);
        textIsDirectVideo = isVideoUrl(textAbs.abs);
      }
    }
    let embedFromText = null;
    if (!embedFromHref && !hrefIsDirectMedia && textEmbed) {
      embedFromText = textEmbed;
      if (embedFromText && !embedFromText.openUrl && textAbs) {
        embedFromText = Object.assign({}, embedFromText, { openUrl: textAbs.abs });
      }
    }
    const textIsDirectMedia = textIsDirectImage || textIsDirectVideo;
    const directVideoFromText = !hrefIsDirectMedia && textIsDirectVideo;
    const directImageFromText = !hrefIsDirectMedia && textIsDirectImage;
    const mediaHintType = (!embedFromHref && (hrefIsDirectMedia || textIsDirectMedia) && textEmbed && textEmbed.type === 'INSTA') ? 'INSTA' : '';
    const embed = embedFromHref || embedFromText;
    if (embed) {
      items.push(makeItem('embed', abs.abs, {
        width: 0,
        height: 0,
        scope: scope,
        origHidden: origHidden,
        source: source,
        openUrl: embed.openUrl || abs.abs,
        embedType: embed.type,
        embedUrl: embed.url,
        el: a
      }, baseUrl));
    }
    if (!embedFromHref && (hrefIsDirectVideo || directVideoFromText)) {
      const mediaUrl = directVideoFromText && textAbs ? textAbs.abs : abs.abs;
      items.push(makeItem('video', mediaUrl, {
        width: 0,
        height: 0,
        scope: scope,
        origHidden: origHidden,
        poster: '',
        source: source,
        openUrl: mediaUrl,
        embedType: mediaHintType,
        el: a
      }, baseUrl));
    } else if (!embedFromHref && (hrefIsDirectImage || directImageFromText)) {
      const mediaUrl = directImageFromText && textAbs ? textAbs.abs : abs.abs;
      items.push(makeItem('img', mediaUrl, {
        width: linkSize.w,
        height: linkSize.h,
        scope: scope,
        origHidden: origHidden,
        source: source,
        openUrl: mediaUrl,
        embedType: mediaHintType,
        el: a
      }, baseUrl));
    }
  });

  const iframes = Array.from(doc.querySelectorAll('iframe[src]'));
  iframes.forEach(function(fr) {
    if (strictBody && !inBodyScope(fr)) return;
    if (inAvoidScope(fr)) return;
    const src = fr.getAttribute('src');
    if (!src) return;
    const abs = normalizeUrl(src, baseUrl || location.href);
    if (!abs) return;
    const info = getEmbedInfoFromIframe(abs.abs);
    if (!info) return;
    const scope = inBodyScope(fr) ? 'body' : '';
    const origHidden = isOriginallyHidden(fr);
    items.push(makeItem('embed', info.openUrl, {
      width: 0,
      height: 0,
      scope: scope,
      origHidden: origHidden,
      source: source,
      openUrl: info.openUrl,
      embedType: info.type,
      embedUrl: info.embedUrl,
      el: fr
    }, baseUrl));
  });

  const bqs = Array.from(doc.querySelectorAll('blockquote.imgur-embed-pub[data-id], blockquote[data-id][class*=\"imgur-embed\"]'));
  bqs.forEach(function(el) {
    if (strictBody && !inBodyScope(el)) return;
    if (inAvoidScope(el)) return;
    const info = getImgurEmbedFromBlockquote(el);
    if (!info) return;
    const scope = inBodyScope(el) ? 'body' : '';
    const origHidden = isOriginallyHidden(el);
    items.push(makeItem('embed', info.openUrl, {
      width: 0,
      height: 0,
      scope: scope,
      origHidden: origHidden,
      source: source,
      openUrl: info.openUrl,
      embedType: 'IMGUR',
      embedUrl: info.embedUrl,
      el: el
    }, baseUrl));
  });

  return items;
}

async function unlockLazy() {
  if (!document.body) return;
  const startY = window.scrollY || 0;
  const maxY = Math.max((document.documentElement.scrollHeight || 0) - window.innerHeight, 0);
  const steps = state.cfg.lazyScrollSteps;
  for (let i = 1; i <= steps; i += 1) {
    if (state.abort.aborted) return;
    window.scrollTo(0, Math.round(maxY * (i / steps)));
    await sleep(state.cfg.lazyDelayMs);
  }
  window.scrollTo(0, startY);
  await sleep(state.cfg.lazyDelayMs);
}

function parseCssUrls(value) {
  const out = [];
  if (!value || value === 'none') return out;
  const re = /url\(("|')?(.*?)("|')?\)/g;
  let m;
  while ((m = re.exec(value))) {
    if (m[2]) out.push(m[2]);
  }
  return out;
}

function extractBackgrounds() {
  const items = [];
  const selector = '[style*="background"], [data-bg], [data-background], [data-bgurl]';
  const nodes = Array.from(document.querySelectorAll(selector)).slice(0, state.cfg.maxBgChecks);
  nodes.forEach(function(node) {
    if (state.cfg.strictBodyOnly && !inBodyScope(node)) return;
    if (inAvoidScope(node)) return;
    const rect = node.getBoundingClientRect ? node.getBoundingClientRect() : { width: 0, height: 0 };
    if (rect.width * rect.height < state.cfg.minArea) return;
    const urls = [];
    if (node.dataset) {
      if (node.dataset.bg) urls.push(node.dataset.bg);
      if (node.dataset.background) urls.push(node.dataset.background);
      if (node.dataset.bgurl) urls.push(node.dataset.bgurl);
    }
    try {
      const style = getComputedStyle(node);
      urls.push.apply(urls, parseCssUrls(style.backgroundImage));
    } catch (e) {}
    const scope = inBodyScope(node) ? 'body' : '';
    const origHidden = isOriginallyHidden(node);
    uniq(urls).forEach(function(u) {
      if (!isImageUrl(u)) return;
      items.push(makeItem('img', u, {
        width: Math.round(rect.width),
        height: Math.round(rect.height),
        scope: scope,
        origHidden: origHidden,
        source: 'bg',
        openUrl: u,
        el: node
      }));
    });
  });
  return items;
}

function extractFromScripts() {
  // DISABLED in rev1.21: strict body-only mode; keep for future toggle
  const items = [];
  const scripts = Array.from(document.querySelectorAll('script'))
    .filter(function(s) { return !s.src && s.textContent; })
    .slice(0, state.cfg.maxScriptCount);
  let buf = '';
  for (let i = 0; i < scripts.length; i += 1) {
    if (buf.length >= state.cfg.maxScriptChars) break;
    buf += scripts[i].textContent.slice(0, state.cfg.maxScriptChars - buf.length);
  }
  if (!buf) return items;
  const re = /(https?:\/\/[^\s'"\\>]+?\.(png|jpe?g|gif|webp|avif|bmp|mp4|webm|mov|m4v))(\?|#|\b)/ig;
  let m;
  while ((m = re.exec(buf))) {
    items.push(makeItem(isVideoUrl(m[1]) ? 'video' : 'img', m[1], {
      width: 0,
      height: 0,
      scope: '',
      source: 'script',
      openUrl: m[1]
    }));
  }
  return items;
}

function extractFromHtmlString() {
  // DISABLED in rev1.21: strict body-only mode; keep for future toggle
  const items = [];
  let html = '';
  try {
    html = (document.documentElement && document.documentElement.outerHTML) || '';
  } catch (e) {}
  if (!html) return items;
  html = html.slice(0, state.cfg.maxHtmlChars).replace(/&amp;/g, '&');
  const re = /(https?:\/\/[^\s'"\\>]+?\.(png|jpe?g|gif|webp|avif|bmp|mp4|webm|mov|m4v))(\?|#|\b)/ig;
  let m;
  while ((m = re.exec(html))) {
    items.push(makeItem(isVideoUrl(m[1]) ? 'video' : 'img', m[1], {
      width: 0,
      height: 0,
      scope: '',
      source: 'html',
      openUrl: m[1]
    }));
  }
  return items;
}

async function collectInitial() {
  updateProgress('scan', 'dom');
  const beforeDom = state.items.list.length;
  addItems(extractFromDocument(document, 'dom', location.href));
  state.log.push('collect', 'dom +' + (state.items.list.length - beforeDom) + ' total=' + state.items.list.length);

  if (state.items.list.length < state.cfg.bgMinItems) {
    await unlockLazy();
    updateProgress('scan', 'lazy');
    const beforeLazy = state.items.list.length;
    addItems(extractFromDocument(document, 'lazy', location.href));
    state.log.push('collect', 'lazy +' + (state.items.list.length - beforeLazy) + ' total=' + state.items.list.length);
  }

  if (state.items.list.length < state.cfg.bgMinItems) {
    updateProgress('scan', 'bg');
    const beforeBg = state.items.list.length;
    addItems(extractBackgrounds());
    state.log.push('collect', 'bg +' + (state.items.list.length - beforeBg) + ' total=' + state.items.list.length);
  }
  state.log.push('collect', 'script/html scans DISABLED (body-only strict)');
}

/* [08] dedup/groupBest */
function makeItem(kind, url, meta, baseUrl) {
  const norm = normalizeUrl(url, baseUrl || location.href);
  if (!norm) return null;
  const pageUrl = baseUrl || location.href;
  const item = {
    id: 'f' + state.items.nextId++,
    kind: kind,
    abs: norm.abs,
    url: norm.canon,
    rawUrl: url,
    groupKey: norm.groupKey,
    host: norm.host,
    width: meta.width || 0,
    height: meta.height || 0,
    scope: meta.scope || '',
    source: meta.source || 'dom',
    openUrl: meta.openUrl || norm.canon,
    poster: meta.poster || '',
    embedType: meta.embedType || '',
    embedUrl: meta.embedUrl || '',
    pageUrl: pageUrl,
    pageLabel: computePageLabel(pageUrl),
    index: state.items.list.length,
    card: null,
    __origHidden: !!meta.origHidden,
    __allHidden: !!meta.origHidden,
    __noiseReason: '',
    __dupClusterUrls: []
  };
  item.dedupKey = canonicalMediaKey(item.abs, kind);
  item.__thumbScore = 0;
  if (kind === 'img') {
    const thumbScore = scoreThumbnailLike(meta.el || null, meta, meta.openUrl || norm.canon);
    item.__thumbScore = thumbScore;
    if (thumbScore >= (state.cfg.thumbLikeMinScore || 0)) {
      item.__isNoise = true;
      item.__noiseReason = 'thumbScore';
    }
  }
  if (item.url) item.__dupClusterUrls.push(item.url);
  item.dupCount = 1;
  item.score = scoreItem(item);
  return item;
}

function registerSeen(key) {
  if (state.seen.map.has(key)) return;
  state.seen.map.set(key, true);
  state.seen.order.push(key);
}

function isSameDupClusterUrl(a, b, kind) {
  if (!a || !b) return false;
  if (a === b) return true;
  if (kind === 'img') return isSameImageVariantUrl(a, b);
  return false;
}

function addDupClusterUrl(item, url) {
  if (!item || !url) return;
  if (!Array.isArray(item.__dupClusterUrls)) item.__dupClusterUrls = [];
  const u = String(url);
  if (!u) return;
  for (let i = 0; i < item.__dupClusterUrls.length; i += 1) {
    if (isSameDupClusterUrl(item.__dupClusterUrls[i], u, item.kind)) return;
  }
  item.__dupClusterUrls.push(u);
}

function mergeDupCluster(target, candidate) {
  if (!target) return;
  addDupClusterUrl(target, target.url || target.abs || '');
  if (!candidate) return;
  addDupClusterUrl(target, candidate.url || candidate.abs || candidate.openUrl || '');
  if (Array.isArray(candidate.__dupClusterUrls)) {
    candidate.__dupClusterUrls.forEach(function(u) {
      addDupClusterUrl(target, u);
    });
  }
}

function getDupClusterHostCounts(item) {
  const counts = Object.create(null);
  if (!item || !Array.isArray(item.__dupClusterUrls)) return counts;
  item.__dupClusterUrls.forEach(function(u) {
    if (!u) return;
    try {
      const host = new URL(String(u), location.href).hostname.toLowerCase();
      if (!host) return;
      counts[host] = (counts[host] || 0) + 1;
    } catch (e) {}
  });
  return counts;
}

function buildDupClusterDetail(item, maxUrls) {
  if (!item || !item.dupCount || item.dupCount < 2) return '';
  const urls = Array.isArray(item.__dupClusterUrls) ? item.__dupClusterUrls.slice() : [];
  const hosts = getDupClusterHostCounts(item);
  const hostEntries = Object.keys(hosts).sort(function(a, b) { return hosts[b] - hosts[a]; });
  const limit = Math.max(1, maxUrls || 6);
  const lines = [];
  lines.push('dup=' + item.dupCount + ' host=' + hostEntries.length + ' url=' + urls.length);
  if (hostEntries.length) {
    const hostLine = hostEntries.map(function(h) {
      return h + ':' + hosts[h];
    }).join(', ');
    lines.push('hosts: ' + hostLine);
  }
  const shown = urls.slice(0, limit);
  shown.forEach(function(u, i) {
    lines.push((i + 1) + '. ' + u);
  });
  if (urls.length > shown.length) {
    lines.push('... +' + (urls.length - shown.length));
  }
  return lines.join('\n');
}

function mergeBest(target, candidate) {
  const keepId = target.id;
  const keepIndex = target.index;
  const keepCard = target.card;
  const keepDup = target.dupCount || 1;
  const keepUrl = target.url;
  const keepEmbedType = target.embedType || '';
  const keepThumbLoaded = target.__thumbLoaded;
  const keepThumbLoading = target.__thumbLoading;
  const keepThumbRetry = target.__thumbRetry;
  const keepThumbCtx = target.__thumbCtx;
  const keepThumbToken = target.__thumbToken;
  const keepIsNoise = target.__isNoise;
  const keepNoiseReason = target.__noiseReason;
  const keepHashDup = target.__hashDup;
  const keepFailed = target.__failed;
  const keepRenderUrl = target.__renderUrl;
  const keepAllHidden = !!target.__allHidden;
  const keepDupClusterUrls = Array.isArray(target.__dupClusterUrls) ? target.__dupClusterUrls.slice() : [];
  Object.assign(target, candidate);
  target.id = keepId;
  target.index = keepIndex;
  target.card = keepCard;
  target.dupCount = keepDup;
  if (!target.embedType && keepEmbedType) target.embedType = keepEmbedType;
  target.__thumbLoaded = keepThumbLoaded;
  target.__thumbLoading = keepThumbLoading;
  target.__thumbRetry = keepThumbRetry;
  target.__thumbCtx = keepThumbCtx;
  target.__thumbToken = keepThumbToken;
  target.__renderUrl = keepRenderUrl;
  target.__dupClusterUrls = keepDupClusterUrls;
  target.__allHidden = keepAllHidden && !!candidate.__allHidden;
  target.__origHidden = target.__allHidden;
  if (keepUrl === target.url) {
    target.__isNoise = keepIsNoise;
    target.__noiseReason = keepNoiseReason;
    target.__hashDup = keepHashDup;
    target.__failed = keepFailed;
  }
  mergeDupCluster(target, candidate);
  target.score = scoreItem(target);
  return target;
}

function adoptItem(item) {
  if (!item) return null;
  if (!passesSize(item) && item.kind !== 'embed') return null;
  const key = item.dedupKey || item.url;
  const existing = state.groupBest.get(key);
  if (existing) {
    const betterByScore = (item.score - existing.score) > 1e-6;
    const betterByQuality = isHigherQualityImageCandidate(item, existing);
    if (betterByScore || betterByQuality) {
      const prevAllHidden = !!existing.__allHidden;
      const prevDup = existing.dupCount || 1;
      mergeBest(existing, item);
      existing.dupCount = prevDup + 1;
      if (existing.card) {
        updateCard(existing);
        updateDupBadge(existing);
      }
      if (prevAllHidden !== !!existing.__allHidden) {
        scheduleApplyFilterSort('origHidden');
      }
      registerSeen(key);
      return existing;
    }
    const prevAllHidden = !!existing.__allHidden;
    let embedTypeChanged = false;
    if (!existing.embedType && item.embedType) {
      existing.embedType = item.embedType;
      embedTypeChanged = true;
    }
    existing.dupCount = (existing.dupCount || 1) + 1;
    existing.__allHidden = prevAllHidden && !!item.__allHidden;
    existing.__origHidden = existing.__allHidden;
    mergeDupCluster(existing, item);
    if (existing.card) updateDupBadge(existing);
    if (embedTypeChanged && existing.card) updateCard(existing);
    if (prevAllHidden !== !!existing.__allHidden) {
      if (existing.card) updateCard(existing);
      scheduleApplyFilterSort('origHidden');
    }
    registerSeen(key);
    return null;
  }
  registerSeen(key);
  if (item.__isNoise) state.items.noiseCount += 1;
  item.index = state.items.list.length;
  state.groupBest.set(key, item);
  state.items.list.push(item);
  state.items.byId.set(item.id, item);
  return item;
}

function addItems(list) {
  if (!list || !list.length) return;
  list.forEach(function(item) {
    const adopted = adoptItem(item);
    if (adopted && !adopted.card) {
      queueRender(adopted);
    }
  });
}

/* [09] crawl */
function sameSite(url) {
  try {
    const u = new URL(url, location.href);
    const host = u.hostname.toLowerCase();
    const cur = location.hostname.toLowerCase();
    if (host === cur) return true;
    const a = host.split('.').slice(-2).join('.');
    const b = cur.split('.').slice(-2).join('.');
    return a && a === b;
  } catch (e) {
    return false;
  }
}

function isSameOriginUrl(url, base) {
  const abs = normalizeCrawlCandidateUrl(url, base || location.href);
  if (!abs) return false;
  try {
    const u = new URL(abs);
    return u.origin === location.origin;
  } catch (e) {
    return false;
  }
}

function normalizeCrawlCandidateUrl(url, base) {
  try {
    const u = new URL(url, base || location.href);
    if (
      location.protocol === 'https:' &&
      u.protocol === 'http:' &&
      u.hostname.toLowerCase() === location.hostname.toLowerCase() &&
      (!u.port || u.port === '80')
    ) {
      u.protocol = 'https:';
      u.port = '';
    }
    return u.toString();
  } catch (e) {
    return '';
  }
}

function normalizeCrawlUrl(url) {
  const normalized = normalizeCrawlCandidateUrl(url, location.href);
  if (!normalized) return '';
  let s = String(normalized).split('#')[0].trim();
  if (!s) return '';
  if (s.endsWith('/') && !/^https?:\/\/[^/]+\/$/.test(s)) {
    s = s.replace(/\/+$/, '');
  }
  return s;
}

function enqueueCrawlLinks(urls) {
  if (!urls || !urls.length) return;
  const maxQ = state.cfg.crawlMaxQueue || 200;
  urls.forEach(function(raw) {
    if (state.crawl.queue.length >= maxQ) return;
    const clean = normalizeCrawlUrl(raw);
    if (!clean) return;
    if (state.crawl.visited.has(clean)) return;
    if (state.crawl.queueDedup.has(clean)) return;
    state.crawl.queueDedup.add(clean);
    state.crawl.queue.push(clean);
  });
}

function collectCrawlLinksFromDocument(doc, baseUrl) {
  const cfg = state.cfg;
  const out = [];
  const nexts = [];
  const base = baseUrl || location.href;
  const preferSameOrigin = !!cfg.crawlPreferSameOriginOnly;
  function allowUrl(u) {
    if (!/^https?:$/.test(u.protocol)) return false;
    if (isImageUrl(u.toString()) || isVideoUrl(u.toString())) return false;
    if (preferSameOrigin) return isSameOriginUrl(u.toString(), base);
    return sameSite(u.toString());
  }
  function pushCandidate(list, href) {
    if (!href) return;
    let u;
    try { u = new URL(href, base); } catch (e) { return; }
    if (!allowUrl(u)) return;
    list.push(u.toString());
  }
  const priLinks = Array.from(doc.querySelectorAll(
    'link[rel~=\"next\"][href], a[rel~=\"next\"][href], a[rel~=\"prev\"][href], #entryPageNav a[href], li.next > a[href], li.prev > a[href], a.next[href], a.prev[href]'
  ));
  priLinks.forEach(function(a) {
    pushCandidate(nexts, a.getAttribute('href'));
  });
  const links = Array.from(doc.querySelectorAll('a[href]'));
  links.forEach(function(a) {
    const href = a.getAttribute('href');
    if (!href || href.startsWith('#')) return;
    pushCandidate(out, href);
  });
  const merged = nexts.concat(out);
  const uniq = [];
  const seen = new Set();
  merged.forEach(function(raw) {
    const key = normalizeCrawlUrl(raw) || raw;
    if (seen.has(key)) return;
    seen.add(key);
    uniq.push(raw);
  });
  return uniq;
}

function collectCrawlLinks() {
  const list = collectCrawlLinksFromDocument(document, location.href);
  if (location.hostname.indexOf('weekly.ascii.jp') !== -1) {
    const rescue = new URL('img.html', location.href).toString();
    if (list.indexOf(rescue) === -1) list.unshift(rescue);
  }
  return list;
}

function buildPagerPlan(baseUrl, doc) {
  if (!isLivedoorArticle(baseUrl)) return null;
  const cap = state.cfg.crawlArticleMaxPages || 30;
  let baseKey = '';
  try {
    const u = new URL(baseUrl, location.href);
    u.search = '';
    u.hash = '';
    baseKey = u.toString();
  } catch (e) {
    return null;
  }
  let max = 1;
  let param = '';
  const links = Array.from(doc.querySelectorAll('a[href]'));
  links.forEach(function(a) {
    const href = a.getAttribute('href');
    if (!href) return;
    let u;
    try { u = new URL(href, baseUrl); } catch (e) { return; }
    if ((u.origin + u.pathname) !== baseKey) return;
    const p = u.searchParams.get('p');
    const page = u.searchParams.get('page');
    const raw = p || page;
    if (!raw) return;
    const n = parseInt(raw, 10);
    if (!n || n < 1) return;
    if (!param) param = page ? 'page' : 'p';
    if (n > max) max = n;
  });
  if (max < 2) {
    const pagerTexts = Array.from(doc.querySelectorAll(
      '.page-current, .article-inner-pager, .pager, .pagination, [class*=\"pager\"], [class*=\"paging\"], [id*=\"pager\"]'
    ))
      .map(function(el) { return String(el.textContent || '').replace(/\s+/g, ' ').trim(); });
    pagerTexts.forEach(function(text) {
      const m = /(\d{1,3})\s*\/\s*(\d{1,3})/.exec(text);
      if (!m) return;
      const total = parseInt(m[2] || '0', 10) || 0;
      if (total > max) max = total;
    });
    if (max > 1 && !param) param = 'p';
  }
  if (max > cap) max = cap;
  if (max < 2) return null;
  if (!param) param = 'p';
  const urls = [];
  for (let n = 2; n <= max; n += 1) {
    urls.push(baseKey + '?' + param + '=' + n);
  }
  return { urls: urls, baseKey: baseKey, param: param, max: max };
}

function isMediaDocument(doc) {
  try {
    const d = doc || document;
    const ct = (d.contentType || '').toLowerCase();
    if (ct.indexOf('image/') === 0 || ct.indexOf('video/') === 0) return true;
    const body = d.body;
    if (!body) return false;
    const kids = Array.from(body.children).filter(function(el) {
      return el.tagName !== 'SCRIPT' && el.tagName !== 'STYLE';
    });
    if (kids.length === 1) {
      const tag = kids[0].tagName;
      if (tag === 'IMG' || tag === 'VIDEO') return true;
    }
  } catch (e) {}
  return false;
}

function countBodySameOriginLinks(doc, baseUrl) {
  let count = 0;
  const links = Array.from(doc.querySelectorAll('a[href]'));
  links.forEach(function(a) {
    if (!inBodyScope(a)) return;
    const href = a.getAttribute('href');
    if (!href || href.startsWith('#')) return;
    let u;
    try { u = new URL(href, baseUrl || location.href); } catch (e) { return; }
    if (!/^https?:$/.test(u.protocol)) return;
    if (!isSameOriginUrl(u.toString(), baseUrl || location.href)) return;
    if (isImageUrl(u.toString()) || isVideoUrl(u.toString())) return;
    count += 1;
  });
  return count;
}

function countImageCandidates() {
  let count = 0;
  state.items.list.forEach(function(it) {
    if (it.kind !== 'img') return;
    if (state.cfg.noiseHide && it.__isNoise) return;
    if (it.__hashDup) return;
    if (it.__failed) return;
    count += 1;
  });
  return count;
}

function countMediaCandidates() {
  let count = 0;
  state.items.list.forEach(function(it) {
    if (it.kind !== 'img' && it.kind !== 'video') return;
    if (it.kind === 'img') {
      if (state.cfg.noiseHide && it.__isNoise) return;
      if (it.__hashDup) return;
      if (it.__failed) return;
    }
    count += 1;
  });
  return count;
}

function isHtmlLikeContentType(value) {
  const ct = String(value || '').toLowerCase();
  if (!ct) return true;
  if (ct.indexOf('text/html') !== -1) return true;
  if (ct.indexOf('application/xhtml+xml') !== -1) return true;
  return false;
}

async function crawlFetch(url) {
  if (state.abort.aborted || state.crawl.stop) return;
  if (state.cfg.crawlPreferSameOriginOnly && !isSameOriginUrl(url)) return;
  const controller = makeController();
  const token = ++state.crawl.token;
  const timer = setTimeout(function() {
    try { controller.abort(); } catch (e) {}
  }, state.cfg.crawlTimeoutMs);
  state.crawl.inFlight += 1;
  updateProgress('net', token);
  try {
    const res = await fetch(url, { signal: controller.signal, credentials: 'same-origin' });
    if (!res.ok) return;
    const contentType = (res.headers && typeof res.headers.get === 'function')
      ? (res.headers.get('content-type') || '')
      : '';
    if (!isHtmlLikeContentType(contentType)) {
      state.log.push('crawl', 'skip non-html ' + url + ' ct=' + (contentType || 'none'));
      return;
    }
    const text = await res.text();
    const html = text.slice(0, state.cfg.maxHtmlChars);
    const doc = new DOMParser().parseFromString(html, 'text/html');
    const items = extractFromDocument(doc, 'crawl', url);
    if (!items.length) {
      state.log.push('crawl', '0 items (strict body-only) ' + url);
    }
    addItems(items);
    if (state.crawl.mode === 'pager') {
      const plan = buildPagerPlan(url, doc);
      if (plan && plan.urls && plan.urls.length) {
        enqueueCrawlLinks(plan.urls);
        state.crawl.pagerBase = plan.baseKey;
        state.crawl.pagerParam = plan.param;
      }
    } else {
      const more = collectCrawlLinksFromDocument(doc, url);
      enqueueCrawlLinks(more.slice(0, state.cfg.crawlMaxNewLinksPerDoc));
    }
    updateProgress('crawl', token);
  } catch (e) {
    state.log.push('crawl', 'fetch error ' + url);
  } finally {
    clearTimeout(timer);
    state.abort.controllers.delete(controller);
    state.crawl.inFlight -= 1;
  }
}

function extractUrlsFromText(html, baseUrl) {
  const items = [];
  const re = /(https?:\/\/[^\s'"\\>]+?\.(png|jpe?g|gif|webp|avif|bmp|mp4|webm|mov|m4v))(\?|#|\b)/ig;
  let m;
  while ((m = re.exec(html))) {
    items.push(makeItem(isVideoUrl(m[1]) ? 'video' : 'img', m[1], {
      width: 0,
      height: 0,
      scope: '',
      source: 'crawl',
      openUrl: m[1]
    }, baseUrl));
  }
  return items;
}

async function startCrawl() {
  if (state.crawl.started) return;
  state.crawl.started = true;
  state.crawl.queue = [];
  state.crawl.queueDedup.clear();
  state.crawl.mode = '';
  state.crawl.pagerBase = '';
  state.crawl.pagerParam = '';
  const plan = buildPagerPlan(location.href, document);
  if (plan && plan.urls && plan.urls.length) {
    state.crawl.mode = 'pager';
    state.crawl.pagerBase = plan.baseKey;
    state.crawl.pagerParam = plan.param;
    enqueueCrawlLinks(plan.urls);
  } else {
    enqueueCrawlLinks(collectCrawlLinks());
  }
  state.crawl.limit = state.cfg.crawlBaseLimit + (state.crawl.allowUserBoost ? state.cfg.crawlBoost : 0);
  if (state.crawl.mode === 'pager') {
    state.crawl.limit = Math.max(state.crawl.limit, state.crawl.queue.length + 2);
  }
  state.log.push('crawl', 'start mode=' + (state.crawl.mode || 'normal') + ' queue=' + state.crawl.queue.length + ' limit=' + state.crawl.limit + ' visited=' + state.crawl.visited.size + ' inFlight=' + state.crawl.inFlight + ' errors=' + state.items.errorCount);
  if (state.crawl.timer) clearTimeout(state.crawl.timer);
  state.crawl.timer = setTimeout(function() { state.crawl.timer = 0; pumpCrawl(); }, 0);
}

async function pumpCrawl() {
  if (state.abort.aborted || state.crawl.stop) {
    state.crawl.done = true;
    maybeFinalize();
    return;
  }
  while (state.crawl.inFlight < state.cfg.crawlConcurrent && state.crawl.queue.length) {
    if (state.crawl.visited.size >= state.crawl.limit) break;
    const url = state.crawl.queue.shift();
    if (state.crawl.visited.has(url)) continue;
    state.crawl.visited.add(url);
    crawlFetch(url).then(pumpCrawl);
  }
  if (!state.crawl.boostedAuto && state.crawl.visited.size >= state.cfg.crawlBaseLimit) {
    const mediaCount = countMediaCandidates();
    if (mediaCount < state.cfg.htmlMinItems) {
      const nextLimit = Math.min(state.cfg.crawlBaseLimit + state.cfg.crawlBoost, state.cfg.crawlBoostLimit || state.cfg.crawlBaseLimit);
      if (nextLimit > state.crawl.limit) {
        state.crawl.limit = nextLimit;
        state.crawl.boostedAuto = true;
        state.log.push('crawl', 'auto-boost limit=' + state.crawl.limit + ' media=' + mediaCount);
      }
    }
  }
  if (state.crawl.inFlight === 0 && (state.crawl.queue.length === 0 || state.crawl.visited.size >= state.crawl.limit)) {
    state.crawl.done = true;
    updateProgress('idle', 'done');
    state.log.push('crawl', 'done visited=' + state.crawl.visited.size + ' inFlight=' + state.crawl.inFlight + ' limit=' + state.crawl.limit + ' errors=' + state.items.errorCount);
    maybeFinalize();
  }
}

function boostCrawl(reason) {
  if (state.crawl.allowUserBoost) return;
  state.crawl.allowUserBoost = true;
  state.crawl.limit = state.cfg.crawlBaseLimit + state.cfg.crawlBoost;
  state.log.push('boost', reason || 'user');
  if (state.crawl.started) pumpCrawl();
}

/* [10] ui-shell */
function createShell() {
  const root = document.createElement('div');
  root.id = ROOT_ID;
  root.style.position = 'fixed';
  root.style.inset = '0';
  root.style.zIndex = '2147483647';
  root.style.pointerEvents = 'none';
  let shadow = null;
  let mount = root;
  try {
    shadow = root.attachShadow({ mode: 'open' });
    mount = shadow;
  } catch (e) {
    shadow = null;
    mount = root;
  }
  const style = document.createElement('style');
  style.textContent = `
    :host { --ui-scale: 1; --lb-scale: 1; }
    :host, * { box-sizing: border-box; }
    .wrap { position: fixed; inset: 0; font-family: "Hiragino Sans", "Avenir Next", "SF Pro Text", sans-serif; color: #eee; --ui-scale: 1; --lb-scale: 1; }
    .wrap.is-iphone { --ui-scale: 1.00; --lb-scale: 1.05; }
    .wrap.is-ipad { --ui-scale: 0.92; --lb-scale: 1.18; }
    .bg { position: absolute; inset: 0; background: #000; pointer-events: none; z-index: 0; }
    .panel { position: absolute; inset: 0; display: flex; flex-direction: column; gap: 8px; padding: calc(env(safe-area-inset-top) + 10px) 10px calc(env(safe-area-inset-bottom) + 10px); background: rgba(0, 0, 0, 0.92); pointer-events: auto; z-index: 1; }
    .header { display: flex; align-items: center; gap: 8px; justify-content: space-between; }
    .title { font-size: calc(16px * var(--ui-scale)); font-weight: 700; letter-spacing: 0.02em; }
    .btns { display: flex; gap: 6px; }
    .btn { font-size: calc(12px * var(--ui-scale)); padding: calc(6px * var(--ui-scale)) calc(10px * var(--ui-scale)); border: 1px solid #555; background: #111; color: #eee; border-radius: 999px; }
    .btn.danger { background: #fff; color: #111; border-color: #fff; }
    .chips { display: flex; flex-wrap: wrap; gap: 6px; }
    .chip { font-size: calc(11px * var(--ui-scale)); padding: calc(6px * var(--ui-scale)) calc(10px * var(--ui-scale)); border-radius: 999px; border: 1px solid #555; background: #111; color: #eee; }
    .chip.active { background: #fff; color: #111; border-color: #fff; }
    .chip-page { font-size: calc(10px * var(--ui-scale)); padding: calc(3px * var(--ui-scale)) calc(6px * var(--ui-scale)); border-radius: 999px; border: 1px solid #444; background: #111; color: #bbb; }
    .info { font-size: calc(12px * var(--ui-scale)); opacity: 0.75; color: #cfcfcf; }
    .progress { font-size: calc(11px * var(--ui-scale)); opacity: 0.65; color: #b0b0b0; }
    .grid { flex: 1; min-height: 0; overflow: auto; display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap: 10px; padding-bottom: 10px; align-content: start; grid-auto-rows: auto; }
    .card { background: #0b0b0b; border-radius: 14px; border: 1px solid #333; overflow: hidden; display: flex; flex-direction: column; position: relative; contain: layout paint; }
    .card.is-hidden { display: none; }
    .card.is-error { opacity: 0.7; }
    .card.is-current { outline: 2px solid #fff; outline-offset: -2px; box-shadow: 0 0 0 2px rgba(255,255,255,0.2); }
    .thumb { border: 0; padding: 0; background: transparent; cursor: pointer; display: block; position: relative; }
    .thumb.is-playable::before, .thumb.is-playable::after { content: ''; position: absolute; left: 50%; top: 50%; pointer-events: none; z-index: 3; }
    .thumb.is-playable::before {
      width: calc(42px * var(--ui-scale));
      height: calc(42px * var(--ui-scale));
      margin-left: calc(-21px * var(--ui-scale));
      margin-top: calc(-21px * var(--ui-scale));
      border-radius: 999px;
      background: rgba(0,0,0,0.35);
      box-shadow: 0 0 0 1px rgba(255,255,255,0.18);
    }
    .thumb.is-playable::after {
      margin-left: calc(-3px * var(--ui-scale));
      margin-top: calc(-9px * var(--ui-scale));
      width: 0;
      height: 0;
      border-style: solid;
      border-width: calc(9px * var(--ui-scale)) 0 calc(9px * var(--ui-scale)) calc(14px * var(--ui-scale));
      border-color: transparent transparent transparent rgba(255,255,255,0.85);
    }
    .thumb img, .thumb video, .thumb .ph { width: 100%; height: 140px; object-fit: contain; object-position: center; display: block; background: #000; }
    .thumb img { transition: opacity 120ms ease; }
    .fmp-gpu { transform: translateZ(0); -webkit-transform: translateZ(0); backface-visibility: hidden; -webkit-backface-visibility: hidden; will-change: opacity, transform; }
    .thumb .ph { display: flex; align-items: center; justify-content: center; font-size: 11px; color: #9a9a9a; }
    .card[data-kind="video"]::after,
    .card[data-kind="embed"]::after,
    .card[data-kind="img"][data-etype="INSTA"]::after {
      content: '';
      position: absolute;
      inset: 0;
      border: 2px solid rgba(255,255,255,0.16);
      border-radius: inherit;
      pointer-events: none;
      z-index: 6;
      transform: translateZ(0);
      -webkit-transform: translateZ(0);
      will-change: transform;
    }
    .card[data-kind="embed"][data-etype="YT"]::after {
      border-color: transparent;
      border-image: linear-gradient(135deg, #ff0033 0%, #ff4e45 55%, #b2071d 100%) 1;
    }
    .card[data-kind="embed"][data-etype="X"]::after {
      border-color: transparent;
      border-image: linear-gradient(135deg, #0f1419 0%, #15202b 55%, #1d9bf0 100%) 1;
    }
    .card[data-kind="embed"][data-etype="TT"]::after {
      border-color: transparent;
      border-image: linear-gradient(135deg, #00f2ea 0%, #111111 50%, #ff0050 100%) 1;
    }
    .card[data-kind="embed"][data-etype="INSTA"]::after,
    .card[data-kind="img"][data-etype="INSTA"]::after {
      border-color: transparent;
      border-image: linear-gradient(135deg, #f58529 0%, #dd2a7b 45%, #8134af 75%, #515bd4 100%) 1;
    }
    .card[data-kind="embed"][data-etype="IMGUR"]::after {
      border-color: transparent;
      border-image: linear-gradient(135deg, #1bb76e 0%, #2ddc85 55%, #0e8f55 100%) 1;
    }
    .card[data-kind="embed"][data-etype="OTHER"]::after { border-color: rgba(255,255,255,0.16); }
    .card[data-kind="video"] .badge { background: rgba(255,255,255,0.20); color: #fff; border: 1px solid rgba(255,255,255,0.35); }
    .card[data-kind="embed"][data-etype="YT"] .badge {
      background: linear-gradient(135deg, #ff0033 0%, #ff4e45 55%, #b2071d 100%);
      color: #fff;
    }
    .card[data-kind="embed"][data-etype="X"] .badge {
      background: linear-gradient(135deg, #0f1419 0%, #15202b 55%, #1d9bf0 100%);
      color: #fff;
    }
    .card[data-kind="embed"][data-etype="TT"] .badge {
      background: linear-gradient(135deg, #00f2ea 0%, #111111 50%, #ff0050 100%);
      color: #fff;
    }
    .card[data-kind="embed"][data-etype="INSTA"] .badge,
    .card[data-kind="img"][data-etype="INSTA"] .badge {
      background: linear-gradient(135deg, #f58529 0%, #dd2a7b 45%, #8134af 75%, #515bd4 100%);
      color: #fff;
    }
    .card[data-kind="embed"][data-etype="IMGUR"] .badge {
      background: linear-gradient(135deg, #1bb76e 0%, #2ddc85 55%, #0e8f55 100%);
      color: #fff;
    }
    .card[data-kind="embed"][data-etype="OTHER"] .badge { background: rgba(255,255,255,0.78); color: #111; }
    .ph-load { position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; background: rgba(0,0,0,0.35); font-size: 11px; color: #bbb; pointer-events: none; transition: opacity 140ms ease; will-change: opacity; }
    .badge {
      position: absolute;
      top: 6px;
      left: 6px;
      width: calc(19px * var(--ui-scale));
      height: calc(19px * var(--ui-scale));
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(255,255,255,0.78);
      color: #111;
      font-size: calc(10px * var(--ui-scale));
      font-weight: 700;
      line-height: 1;
      padding: 0;
      border-radius: calc(7px * var(--ui-scale));
      z-index: 8;
      transform: translateZ(0);
      -webkit-transform: translateZ(0);
    }
    .hlabel {
      position: absolute;
      left: 6px;
      bottom: 6px;
      font-size: calc(10px * var(--ui-scale));
      line-height: 1;
      padding: 2px 6px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.20);
      background: rgba(0,0,0,0.55);
      color: #fff;
      z-index: 8;
      display: none;
      pointer-events: none;
    }
    .card[data-oh="1"] .hlabel { display: block; }
    .dup-badge { position: absolute; top: 6px; right: 6px; background: #111; color: #eee; font-size: 10px; padding: 2px 6px; border-radius: 999px; border: 1px solid #555; display: none; z-index: 2; cursor: pointer; max-width: 72%; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .meta { display: flex; justify-content: space-between; align-items: center; padding: 6px 8px; font-size: 11px; color: #bbb; }
    .open { text-decoration: none; font-size: 14px; padding: 4px 6px; border-radius: 6px; border: 1px solid #555; color: #eee; }
    .inline { font-size: 11px; padding: 4px 6px; border-radius: 6px; border: 1px solid #555; background: #111; color: #eee; }
    .lb { position: fixed; inset: 0; background: rgba(0, 0, 0, 0.92); display: none; align-items: center; justify-content: center; padding: calc(env(safe-area-inset-top) + 16px) 12px calc(env(safe-area-inset-bottom) + 16px); z-index: 2; pointer-events: auto; }
    .lb.open { display: flex; }
    .lb-frame { max-width: 92vw; max-height: 78vh; border-radius: 16px; overflow: hidden; background: #000; display: flex; align-items: center; justify-content: center; position: relative; border: 2px solid rgba(255,255,255,0.16); box-sizing: border-box; }
    .lb[data-kind="embed"][data-etype="YT"] .lb-frame {
      border-color: transparent;
      border-image: linear-gradient(135deg, #ff0033 0%, #ff4e45 55%, #b2071d 100%) 1;
    }
    .lb[data-kind="embed"][data-etype="X"] .lb-frame {
      border-color: transparent;
      border-image: linear-gradient(135deg, #0f1419 0%, #15202b 55%, #1d9bf0 100%) 1;
    }
    .lb[data-kind="embed"][data-etype="TT"] .lb-frame {
      border-color: transparent;
      border-image: linear-gradient(135deg, #00f2ea 0%, #111111 50%, #ff0050 100%) 1;
    }
    .lb[data-etype="INSTA"] .lb-frame {
      border-color: transparent;
      border-image: linear-gradient(135deg, #f58529 0%, #dd2a7b 45%, #8134af 75%, #515bd4 100%) 1;
    }
    .lb[data-kind="embed"][data-etype="IMGUR"] .lb-frame {
      border-color: transparent;
      border-image: linear-gradient(135deg, #1bb76e 0%, #2ddc85 55%, #0e8f55 100%) 1;
    }
    .lb[data-kind="embed"][data-etype="OTHER"] .lb-frame { border-color: rgba(255,255,255,0.16); }
    .lb-frame img, .lb-frame video, .lb-frame canvas { max-width: 92vw; max-height: 78vh; object-fit: contain; display: block; }
    .lb-frame img { transition: opacity 120ms; transform: translateZ(0); -webkit-transform: translateZ(0); backface-visibility: hidden; -webkit-backface-visibility: hidden; will-change: opacity, transform; }
    .lb-controls { position: fixed; bottom: calc(env(safe-area-inset-bottom) + 16px); left: 0; right: 0; display: flex; justify-content: center; gap: 10px; }
    .wrap.is-iphone .lb-controls,
    .wrap.is-ipad .lb-controls { justify-content: flex-start; padding-left: calc(env(safe-area-inset-left) + 14px); padding-right: 0; }
    .lb-btn { background: #fff; color: #111; border-radius: 999px; border: 0; padding: calc(8px * var(--lb-scale)) calc(14px * var(--lb-scale)); font-size: calc(12px * var(--lb-scale)); }
    .lb-badge {
      position: absolute;
      top: 8px;
      right: 8px;
      background: #fff;
      color: #111;
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 6px;
      white-space: pre-wrap;
      max-width: 70vw;
      line-height: 1.2;
      text-align: right;
    }
    .lb-embed { width: 92vw; height: 70vh; border: 0; background: #000; }
    .lb-video-fallback { width: 92vw; height: 70vh; border: 0; background: #000; border-radius: 16px; }
    .lb-tap { position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; background: rgba(0,0,0,0.55); color: #fff; border: 0; font-size: 12px; }
    .embed { width: 100%; border: 0; height: ${state.cfg.embedHeight}px; }
    @media (min-width: 900px) {
      .grid { grid-template-columns: repeat(auto-fill, minmax(180px, 1fr)); }
      .thumb img, .thumb video, .thumb .ph { height: 180px; }
    }
  `;
  const wrap = document.createElement('div');
  wrap.className = 'wrap';
  if (state.env.isIPhone) wrap.classList.add('is-iphone');
  if (state.env.isIPad) wrap.classList.add('is-ipad');
  const bg = document.createElement('div');
  bg.className = 'bg';
  bg.style.setProperty('pointer-events', 'none', 'important');
  bg.style.setProperty('z-index', '0', 'important');
  const panel = document.createElement('div');
  panel.className = 'panel';
  panel.style.setProperty('pointer-events', 'auto', 'important');
  panel.style.setProperty('z-index', '1', 'important');

  const header = document.createElement('div');
  header.className = 'header';
  const title = document.createElement('div');
  title.className = 'title';
  title.textContent = SCRIPT_NAME + ' rev' + SCRIPT_REV;
  const btns = document.createElement('div');
  btns.className = 'btns';
  const closeBtn = mkBtn('閉じる', 'btn');
  const stopBtn = mkBtn('巡回停止', 'btn danger');
  const logBtn = mkBtn('ログコピー', 'btn');
  btns.appendChild(closeBtn);
  btns.appendChild(stopBtn);
  btns.appendChild(logBtn);
  header.appendChild(title);
  header.appendChild(btns);

  const filterBar = document.createElement('div');
  filterBar.className = 'chips';
  ['BODY', 'IMG', 'VIDEO', 'X', 'INSTA', 'IMGUR', 'YT', 'TT', 'ALL'].forEach(function(key) {
    const label = (key === 'BODY') ? '本文' : key;
    const chip = mkBtn(label, 'chip');
    chip.setAttribute('data-filter', key);
    filterBar.appendChild(chip);
  });
  const hiddenChip = mkBtn('非表示', 'chip');
  hiddenChip.setAttribute('data-action', 'toggle-hidden');
  filterBar.appendChild(hiddenChip);
  const boostChip = mkBtn('巡回+', 'chip');
  boostChip.setAttribute('data-action', 'boost-crawl');
  filterBar.appendChild(boostChip);

  const sortBar = document.createElement('div');
  sortBar.className = 'chips';
  ['DEFAULT', 'SIZE'].forEach(function(key) {
    const chip = mkBtn(key, 'chip');
    chip.setAttribute('data-sort', key);
    sortBar.appendChild(chip);
  });

  const info = document.createElement('div');
  info.className = 'info';
  info.textContent = 'loading...';

  const progress = document.createElement('div');
  progress.className = 'progress';
  progress.textContent = 'idle';

  const grid = document.createElement('div');
  grid.className = 'grid';

  panel.appendChild(header);
  panel.appendChild(filterBar);
  panel.appendChild(sortBar);
  panel.appendChild(info);
  panel.appendChild(progress);
  panel.appendChild(grid);

  wrap.appendChild(bg);
  wrap.appendChild(panel);
  mount.appendChild(style);
  mount.appendChild(wrap);

  state.ui.root = root;
  state.ui.shadow = shadow;
  state.ui.wrap = wrap;
  state.ui.header = header;
  state.ui.filterBar = filterBar;
  state.ui.sortBar = sortBar;
  state.ui.logBtn = logBtn;
  state.ui.grid = grid;
  state.ui.info = info;
  state.ui.progress = progress;

  function bindUiTap(el, handler) {
    if (!el || typeof handler !== 'function') return;
    let lastTouchLikeTs = 0;
    const onTap = function(ev) {
      const now = Date.now();
      if (ev.type === 'click' && (now - lastTouchLikeTs) < 450) {
        try { ev.preventDefault(); } catch (e) {}
        return;
      }
      if (ev.type !== 'click') {
        lastTouchLikeTs = now;
        try { ev.preventDefault(); } catch (e) {}
      }
      handler(ev);
    };
    el.addEventListener('click', onTap);
    el.addEventListener('pointerup', onTap);
    el.addEventListener('touchend', onTap, { passive: false });
  }

  bindUiTap(closeBtn, function(ev) {
    ev.preventDefault();
    cleanupUi();
    finalize('ok', { reason: 'closed' });
  });
  bindUiTap(stopBtn, function(ev) {
    ev.preventDefault();
    abortAll('user');
    state.crawl.stop = true;
    state.crawl.queue.length = 0;
    state.crawl.queueDedup.clear();
    if (state.crawl.timer) {
      clearTimeout(state.crawl.timer);
      state.crawl.timer = 0;
    }
    state.log.push('crawl', 'stopped visited=' + state.crawl.visited.size + ' inFlight=' + state.crawl.inFlight + ' limit=' + state.crawl.limit + ' errors=' + state.items.errorCount);
    updateProgress('idle', 'stopped');
  });
  bindUiTap(logBtn, function(ev) {
    ev.preventDefault();
    if (state.log.copy) state.log.copy();
  });

  bindUiTap(filterBar, function(ev) {
    const target = ev.target && ev.target.nodeType === 1 ? ev.target : (ev.target && ev.target.parentElement ? ev.target.parentElement : null);
    if (!target || !target.closest) return;
    const hiddenBtn = target.closest('[data-action="toggle-hidden"]');
    if (hiddenBtn) {
      state.cfg.hiddenHide = !state.cfg.hiddenHide;
      setInfoTemp(state.cfg.hiddenHide ? '非表示画像OFF' : '非表示画像ON', 1200);
      applyFilterSort();
      updateChipUI();
      return;
    }
    const actionBtn = target.closest('[data-action="boost-crawl"]');
    if (actionBtn) {
      if (state.crawl.allowUserBoost) {
        setInfoTemp('巡回拡張済', 900);
        return;
      }
      boostCrawl('chip');
      setInfoTemp('巡回拡張ON', 900);
      updateChipUI();
      return;
    }
    const btn = target.closest('[data-filter]');
    if (!btn) return;
    const key = btn.getAttribute('data-filter');
    if (key === 'ALL') {
      const now = Date.now();
      if (now - state.ui.lastAllTap < 500) {
        state.cfg.noiseHide = !state.cfg.noiseHide;
        setInfoTemp(state.cfg.noiseHide ? 'ノイズ表示OFF' : 'ノイズ表示ON', 1200);
      }
      state.ui.lastAllTap = now;
    }
    setFilter(key);
  });
  bindUiTap(sortBar, function(ev) {
    const target = ev.target && ev.target.nodeType === 1 ? ev.target : (ev.target && ev.target.parentElement ? ev.target.parentElement : null);
    if (!target || !target.closest) return;
    const btn = target.closest('[data-sort]');
    if (!btn) return;
    setSort(btn.getAttribute('data-sort'));
  });

  state.ui.progressTimer = setInterval(function() {
    if (!state.ui.progress) return;
    if (Date.now() - state.ui.progressLast > state.cfg.progressStaleMs) {
      state.ui.progress.textContent = 'idle';
    }
  }, 500);
  initThumbLoader();
}

function mountShell(attempt) {
  const root = state.ui.root;
  if (!root || root.isConnected) return;
  const host = document.body || document.documentElement;
  try {
    if (host) host.appendChild(root);
  } catch (e) {}
  if (!root.isConnected && (attempt || 0) < 12) {
    requestAnimationFrame(function() { mountShell((attempt || 0) + 1); });
  }
}

function lockPage(state) {
  if (state.ui.locked) return;
  try { state.ui.prevOverflow = document.documentElement.style.overflow || ''; } catch (e) {}
  try { state.ui.prevBodyOverflow = document.body ? (document.body.style.overflow || '') : ''; } catch (e) {}
  try { document.documentElement.style.overflow = 'hidden'; } catch (e) {}
  try { if (document.body) document.body.style.overflow = 'hidden'; } catch (e) {}
  try { if (document.documentElement) document.documentElement.dataset.fmpLocked = '1'; } catch (e) {}
  try { if (document.body) document.body.dataset.fmpLocked = '1'; } catch (e) {}
  if (state.ui.root) state.ui.root.style.pointerEvents = 'auto';
  state.ui.locked = true;
}

function unlockPage(state) {
  const htmlMarked = document.documentElement && document.documentElement.dataset && document.documentElement.dataset.fmpLocked === '1';
  const bodyMarked = document.body && document.body.dataset && document.body.dataset.fmpLocked === '1';
  if (!state.ui.locked && !htmlMarked && !bodyMarked) {
    if (state.ui.root) state.ui.root.style.pointerEvents = 'none';
    return;
  }
  if (htmlMarked) {
    try { document.documentElement.style.overflow = state.ui.prevOverflow || ''; } catch (e) {}
    try { delete document.documentElement.dataset.fmpLocked; } catch (e) {}
  }
  if (bodyMarked) {
    try { if (document.body) document.body.style.overflow = state.ui.prevBodyOverflow || ''; } catch (e) {}
    try { if (document.body) delete document.body.dataset.fmpLocked; } catch (e) {}
  }
  if (state.ui.root) state.ui.root.style.pointerEvents = 'none';
  state.ui.locked = false;
}

function isUiVisible(state) {
  const root = state.ui.root;
  const wrap = state.ui.wrap;
  const grid = state.ui.grid;
  if (!root || !root.isConnected) return false;
  if (!wrap || !wrap.isConnected) return false;
  if (!grid || !grid.isConnected) return false;
  try {
    const rect = grid.getBoundingClientRect();
    if (rect.height < 60) return false;
    const cs = getComputedStyle(wrap);
    if (cs.display === 'none') return false;
    if (cs.visibility === 'hidden') return false;
    if (cs.opacity === '0') return false;
    return true;
  } catch (e) {
    return false;
  }
}

function restoreUiState() {
  if (!state.ui.root || !state.ui.root.isConnected) return;
  if (state.ui.locked) {
    try { if (document.documentElement) { document.documentElement.style.overflow = 'hidden'; document.documentElement.dataset.fmpLocked = '1'; } } catch (e) {}
    try { if (document.body) { document.body.style.overflow = 'hidden'; document.body.dataset.fmpLocked = '1'; } } catch (e) {}
    state.ui.root.style.pointerEvents = 'auto';
  } else {
    state.ui.root.style.pointerEvents = 'none';
  }
  if (state.lb.open && state.lb.overlay) {
    state.lb.overlay.classList.add('open');
  }
}

function bindVisibilityHandlers() {
  if (state.ui.boundVis) return;
  state.ui.boundVis = true;
  if (!state.ui.onVisibilityChange) {
    state.ui.onVisibilityChange = function() {
      if (document.visibilityState === 'visible') restoreUiState();
    };
  }
  if (!state.ui.onPageShow) {
    state.ui.onPageShow = function() {
      restoreUiState();
    };
  }
  if (!state.ui.onFocus) {
    state.ui.onFocus = function() {
      restoreUiState();
    };
  }
  document.addEventListener('visibilitychange', state.ui.onVisibilityChange);
  window.addEventListener('pageshow', state.ui.onPageShow);
  window.addEventListener('focus', state.ui.onFocus);
}

function showBootBadge(message) {
  const wrap = state.ui.wrap;
  if (!wrap) return;
  const badge = document.createElement('div');
  badge.textContent = message;
  badge.style.position = 'fixed';
  badge.style.top = '12px';
  badge.style.right = '12px';
  badge.style.zIndex = '2147483647';
  badge.style.background = '#111';
  badge.style.color = '#eee';
  badge.style.border = '1px solid #444';
  badge.style.borderRadius = '10px';
  badge.style.padding = '6px 8px';
  badge.style.fontSize = '11px';
  wrap.appendChild(badge);
  setTimeout(function() {
    if (badge.parentNode) badge.parentNode.removeChild(badge);
  }, 1800);
}

function showBootBadgeGlobal(message) {
  const host = document.body || document.documentElement;
  if (!host) return;
  const badge = document.createElement('div');
  badge.textContent = message;
  badge.style.position = 'fixed';
  badge.style.top = '12px';
  badge.style.right = '12px';
  badge.style.zIndex = '2147483647';
  badge.style.background = '#111';
  badge.style.color = '#eee';
  badge.style.border = '1px solid #444';
  badge.style.borderRadius = '10px';
  badge.style.padding = '6px 8px';
  badge.style.fontSize = '11px';
  host.appendChild(badge);
  setTimeout(function() {
    if (badge.parentNode) badge.parentNode.removeChild(badge);
  }, 1800);
}

/* [11] cards */
function mkBtn(text, cls) {
  const btn = document.createElement('button');
  btn.type = 'button';
  btn.textContent = text;
  btn.className = cls;
  btn.style.pointerEvents = 'auto';
  btn.style.touchAction = 'manipulation';
  return btn;
}

function showThumbOverlay(card, text) {
  if (!card) return null;
  const thumb = card.querySelector('.thumb');
  if (!thumb) return null;
  let overlay = thumb.querySelector('.ph-load');
  if (!overlay) {
    overlay = document.createElement('div');
    overlay.className = 'ph-load';
    thumb.appendChild(overlay);
  }
  overlay.textContent = text || 'LOADING';
  if (overlay.__hideTimer) {
    clearTimeout(overlay.__hideTimer);
    overlay.__hideTimer = 0;
  }
  overlay.style.display = 'flex';
  overlay.style.opacity = '0';
  return overlay;
}

function clearOverlayShowTimer(item) {
  if (!item) return;
  if (item.__overlayShowTimer) {
    clearTimeout(item.__overlayShowTimer);
    item.__overlayShowTimer = 0;
  }
}

function scheduleOverlayShow(item, overlay, delayMs) {
  if (!item || !overlay) return;
  clearOverlayShowTimer(item);
  const wait = typeof delayMs === 'number' ? delayMs : 120;
  const alreadyVisible = overlay.style.opacity === '1';
  overlay.style.display = 'flex';
  if (!alreadyVisible) overlay.style.opacity = '0';
  item.__overlayShowTimer = setTimeout(function() {
    item.__overlayShowTimer = 0;
    if (!item.__thumbLoading) return;
    if (!overlay || !overlay.isConnected) return;
    if (overlay.style.display === 'none') return;

    // スクロール中はUI反映を遅延
    if (state.thumb && state.thumb.pausedByScroll) {
      thumbQueueUi(function() {
        if (!overlay || !overlay.isConnected) return;
        if (overlay.style.display === 'none') return;
        overlay.style.opacity = '1';
      });
      return;
    }
    overlay.style.opacity = '1';
  }, wait);
}

function hideThumbOverlay(card) {
  if (!card) return;
  const overlay = card.querySelector('.ph-load');
  if (!overlay) return;
  if (overlay.__hideTimer) {
    clearTimeout(overlay.__hideTimer);
    overlay.__hideTimer = 0;
  }
  if (overlay.style.opacity === '0') {
    overlay.style.display = 'none';
    return;
  }
  overlay.style.opacity = '0';
  overlay.__hideTimer = setTimeout(function() {
    overlay.__hideTimer = 0;
    if (overlay) overlay.style.display = 'none';
  }, 160);
}

function thumbQueueUi(fn) {
  try {
    if (!state.thumb) return;
    if (!state.thumb.uiQueue) state.thumb.uiQueue = [];
    if (typeof state.thumb.uiQueueHead !== 'number') state.thumb.uiQueueHead = 0;
    state.thumb.uiQueue.push(fn);
    if (!state.thumb.pausedByScroll) thumbScheduleUiFlush();
  } catch (e) {}
}

function thumbScheduleUiFlush() {
  if (!state.thumb) return;
  if (state.thumb.uiFlushScheduled) return;
  state.thumb.uiFlushScheduled = true;
  requestAnimationFrame(thumbFlushUiQueue);
}

function thumbFlushUiQueue() {
  if (!state.thumb) return;
  state.thumb.uiFlushScheduled = false;
  if (state.thumb.pausedByScroll) return;
  const q = state.thumb.uiQueue;
  if (!q || !q.length) {
    state.thumb.uiQueueHead = 0;
    return;
  }
  let head = state.thumb.uiQueueHead || 0;
  if (head >= q.length) {
    q.length = 0;
    state.thumb.uiQueueHead = 0;
    return;
  }

  const batch = state.cfg.thumbUiBatchPerFrame ||
    ((state.env && state.env.isIPhone) ? 6 : 12);

  let n = 0;
  while (n < batch && head < q.length) {
    const fn = q[head++];
    try { if (fn) fn(); } catch (e) {}
    n++;
  }
  state.thumb.uiQueueHead = head;
  if (head > 64 && head * 2 >= q.length) {
    state.thumb.uiQueue = q.slice(head);
    state.thumb.uiQueueHead = 0;
  }
  const remain = state.thumb.uiQueue && ((state.thumb.uiQueue.length - (state.thumb.uiQueueHead || 0)) > 0);
  if (remain) {
    state.thumb.uiFlushScheduled = true;
    requestAnimationFrame(thumbFlushUiQueue);
  }
}

function applyTempGpuClass(img) {
  if (!img || !img.classList) return;
  try {
    if (img.__fmpGpuRaf1) cancelAnimationFrame(img.__fmpGpuRaf1);
    if (img.__fmpGpuRaf2) cancelAnimationFrame(img.__fmpGpuRaf2);
  } catch (e) {}
  img.classList.add('fmp-gpu');
  img.__fmpGpuRaf1 = requestAnimationFrame(function() {
    img.__fmpGpuRaf2 = requestAnimationFrame(function() {
      try {
        if (img && img.classList) img.classList.remove('fmp-gpu');
      } catch (e) {}
      img.__fmpGpuRaf1 = 0;
      img.__fmpGpuRaf2 = 0;
    });
  });
}

function queueRepaint(img) {
  if (!img || !img.isConnected || !state.thumb) return;
  if (!state.thumb.repaintSet) state.thumb.repaintSet = new Set();
  state.thumb.repaintSet.add(img);
  if (state.thumb.repaintRaf) return;
  state.thumb.repaintRaf = requestAnimationFrame(flushRepaintQueue);
}

function flushRepaintQueue() {
  if (!state.thumb) return;
  state.thumb.repaintRaf = 0;
  const set = state.thumb.repaintSet;
  if (!set || !set.size) return;
  const list = Array.from(set);
  set.clear();
  try {
    const host = document.body || document.documentElement;
    if (host) void host.offsetHeight;
  } catch (e) {}
  const restore = [];
  list.forEach(function(img) {
    if (!img || !img.isConnected) return;
    applyTempGpuClass(img);
    forceRepaintImage(img, restore);
  });
  if (restore.length) {
    requestAnimationFrame(function() {
      restore.forEach(function(fn) {
        try { if (fn) fn(); } catch (e) {}
      });
    });
  }
  if (state.thumb.repaintSet && state.thumb.repaintSet.size && !state.thumb.repaintRaf) {
    state.thumb.repaintRaf = requestAnimationFrame(flushRepaintQueue);
  }
}

function thumbApplyFit(img) {
  try {
    if (!img || !img.isConnected) return;
    const w = img.naturalWidth || 0;
    const h = img.naturalHeight || 0;
    if (!w || !h) return;
    const box = (state.env && state.env.thumbBoxPx) ? state.env.thumbBoxPx : ((state.env && state.env.isWide) ? 180 : 140);
    const cw = Math.round(box || 0);
    const ch = Math.round(box || 0);
    if (!cw || !ch) return;

    if (w <= cw && h <= ch) {
      img.style.objectFit = 'none';
      img.style.objectPosition = 'center';
    } else {
      img.style.objectFit = 'contain';
      img.style.objectPosition = 'center';
    }
  } catch (e) {}
}

function applyThumbMetrics(item, img, card) {
  try {
    const w = img.naturalWidth || 0;
    const h = img.naturalHeight || 0;
    if (w && h) {
      if (!item.width || !item.height) {
        item.width = w;
        item.height = h;
      }
      item.score = scoreItem(item);
      const area = w * h;
      const aspect = Math.max(w / h, h / w);
      const smallThumb = (state.cfg.thumbSmallMaxW > 0 && state.cfg.thumbSmallMaxH > 0 &&
        w <= state.cfg.thumbSmallMaxW && h <= state.cfg.thumbSmallMaxH);
      let noiseReason = '';
      if (smallThumb) noiseReason = 'smallPx';
      else if (w < state.cfg.noiseMinW || h < state.cfg.noiseMinH) noiseReason = 'smallDim';
      else if (area < state.cfg.noiseMinArea) noiseReason = 'smallArea';
      else if (aspect > state.cfg.noiseMaxAspect) noiseReason = 'extremeAspect';
      const isNoise = smallThumb || (w < state.cfg.noiseMinW) ||
        (h < state.cfg.noiseMinH) ||
        (area < state.cfg.noiseMinArea) ||
        (aspect > state.cfg.noiseMaxAspect);
      if (isNoise && !item.__isNoise) {
        item.__isNoise = true;
        state.items.noiseCount += 1;
      }
      if (isNoise) {
        item.__noiseReason = noiseReason || item.__noiseReason || 'noise';
      }
      if (card) {
        const dim = card.querySelector('.meta div');
        if (dim) dim.textContent = formatItemMetaText(item);
      }
      if (isNoise && state.cfg.noiseHide && card) {
        card.classList.add('is-hidden');
      }
      if (state.thumb && state.thumb.pausedByScroll) {
        if (state.ui) state.ui.__infoDirty = true;
      } else {
        updateInfo();
      }

      // スクロール中はrect計測を避け、後で分割適用
      if (state.thumb && state.thumb.pausedByScroll) {
        if (img && img.dataset) {
          if (img.dataset.fmpFitQueued === '1') return;
          img.dataset.fmpFitQueued = '1';
        }
        thumbQueueUi(function() {
          try {
            if (img && img.dataset) img.dataset.fmpFitQueued = '0';
          } catch (e) {}
          thumbApplyFit(img);
        });
        return;
      }

      thumbApplyFit(img);
    }
  } catch (e) {}
}

function isRectInGridView(rect, gridRect) {
  if (!rect || !gridRect) return false;
  return rect.bottom >= gridRect.top && rect.top <= gridRect.bottom;
}

function isCardInGridView(card, gridRect) {
  if (!card || typeof card.getBoundingClientRect !== 'function') return false;
  let cardRect = null;
  try {
    cardRect = card.getBoundingClientRect();
  } catch (e) {
    cardRect = null;
  }
  if (!cardRect) return false;
  let g = gridRect || null;
  if (!g && state.ui && state.ui.grid && typeof state.ui.grid.getBoundingClientRect === 'function') {
    try {
      g = state.ui.grid.getBoundingClientRect();
    } catch (e) {
      g = null;
    }
  }
  if (!g) return false;
  return isRectInGridView(cardRect, g);
}

function isEntryInGridView(entry, gridRect) {
  if (!entry || !entry.boundingClientRect || !gridRect) return false;
  return isRectInGridView(entry.boundingClientRect, gridRect);
}

function resolveIoGridRect(entry) {
  if (entry && entry.rootBounds) {
    if (state.thumb) state.thumb.lastIoRootRect = entry.rootBounds;
    return entry.rootBounds;
  }
  if (state.thumb && state.thumb.lastIoRootRect) return state.thumb.lastIoRootRect;
  return null;
}

function revealThumb(card, img) {
  // スクロール中はUI反映を遅延（ただし表示中カードは即時反映）
  let scrolling = false;
  let inViewNow = false;
  if (state.thumb && state.thumb.pausedByScroll) {
    scrolling = true;
    let resolvedFromIO = false;
    if (state.thumb.observer && card && card.dataset && card.dataset.id) {
      const item = state.items && state.items.byId ? state.items.byId.get(card.dataset.id) : null;
      if (item) {
        inViewNow = !!item.__thumbInView;
        resolvedFromIO = true;
      }
    }
    if (!resolvedFromIO) {
      let gridRect = null;
      if (state.ui && state.ui.grid && typeof state.ui.grid.getBoundingClientRect === 'function') {
        try {
          gridRect = state.ui.grid.getBoundingClientRect();
        } catch (e) {
          gridRect = null;
        }
      }
      inViewNow = isCardInGridView(card, gridRect);
    }
  }

  if (scrolling && !inViewNow) {
    if (img && img.dataset) {
      if (img.dataset.fmpRevealQueued === '1') return;
      img.dataset.fmpRevealQueued = '1';
    }
    thumbQueueUi(function() {
      try {
        if (img && img.dataset) img.dataset.fmpRevealQueued = '0';
      } catch (e) {}
      if (img && img.isConnected) img.style.opacity = '1';
      if (card && card.isConnected) hideThumbOverlay(card);

      if (img && img.isConnected) {
        queueRepaint(img);
        if (state.env && state.env.isIOS && state.thumb && state.thumb.pausedByScroll) {
          const nudged = img.dataset ? img.dataset.fmpNudged : img.getAttribute('data-fmp-nudged');
          if (nudged !== '1') {
            if (img.dataset) img.dataset.fmpNudged = '1';
            else img.setAttribute('data-fmp-nudged', '1');
            setTimeout(function() {
              queueRepaint(img);
            }, 30);
          }
        }
      }
    });
    return;
  }

  // 通常（非スクロール中）または表示中カードは即反映
  if (img) img.style.opacity = '1';
  hideThumbOverlay(card);
  if (img) {
    queueRepaint(img);
    if (state.env && state.env.isIOS && state.thumb && state.thumb.pausedByScroll) {
      const nudged = img.dataset ? img.dataset.fmpNudged : img.getAttribute('data-fmp-nudged');
      if (nudged !== '1') {
        if (img.dataset) img.dataset.fmpNudged = '1';
        else img.setAttribute('data-fmp-nudged', '1');
        setTimeout(function() {
          queueRepaint(img);
        }, 30);
      }
    }
  }
}

function getThumbMaxConcurrent() {
  if (state.env.isIPhone) {
    let max = state.cfg.thumbConcurrentIphone || 3;
    const count = state.items && state.items.list ? state.items.list.length : 0;
    if (count >= 320) max = Math.min(max, 1);
    else if (count >= 180) max = Math.min(max, 2);
    return max;
  }
  if (state.env.isIPad) return state.cfg.thumbConcurrentIpad || 4;
  return Math.max(state.cfg.thumbConcurrentIpad || 4, 6);
}

function getThumbMaxConcurrentWhileScroll() {
  if (state.env && state.env.isIPhone) {
    if (state.env.isHighHz === true) return 2;
    return 1;
  }
  if (state.env && state.env.isIPad) return 2;
  return 3;
}

function shouldSkipThumbDecode() {
  const count = state.items && state.items.list ? state.items.list.length : 0;
  if (state.env && state.env.isIPhone) return count >= 240;
  if (state.env && state.env.isIPad) return count >= 360;
  return false;
}

function getAdaptiveThumbRootMarginPx() {
  const base = state.cfg.thumbRootMarginPx || 0;
  const count = state.items && state.items.list ? state.items.list.length : 0;
  if (state.env && state.env.isIPhone) {
    if (count >= 320) return 300;
    if (count >= 180) return 450;
    return base;
  }
  if (state.env && state.env.isIPad) {
    if (count >= 320) return 520;
    return base;
  }
  return base;
}

function initThumbLoader() {
  if (!state.thumb || !state.ui.grid) return;
  if (state.thumb.__inited) return;
  state.thumb.__inited = true;
  state.thumb.max = getThumbMaxConcurrent();
  state.thumb.pausedByScroll = false;
  state.thumb.scrollPauseUntil = 0;

  // UI遅延キュー（スクロール中のガクつき対策）
  if (!state.thumb.uiQueue) state.thumb.uiQueue = [];
  if (typeof state.thumb.uiQueueHead !== 'number') state.thumb.uiQueueHead = 0;
  state.thumb.uiFlushScheduled = false;

  const root = state.ui.grid;
  let scheduled = false;
  const scan = function() {
    scheduled = false;
    const grid = state.ui.grid;
    if (!grid) return;
    const rect = grid.getBoundingClientRect();
    const margin = getAdaptiveThumbRootMarginPx();
    const top = rect.top - margin;
    const bottom = rect.bottom + margin;
    const cards = Array.from(grid.querySelectorAll('.card'));
    cards.forEach(function(card) {
      const r = card.getBoundingClientRect();
      if (r.bottom >= top && r.top <= bottom) {
        const item = state.items.byId.get(card.dataset.id);
        if (item) thumbEnqueue(item);
      }
    });
  };
  const schedule = function() {
    if (scheduled) return;
    scheduled = true;
    requestAnimationFrame(scan);
  };
  let kickScheduled = false;
  const kickScanNow = function() {
    if (kickScheduled) return;
    kickScheduled = true;
    requestAnimationFrame(function() {
      kickScheduled = false;
      const obs = state.thumb ? state.thumb.observer : null;
      if (!obs) return;
      let entries = [];
      try {
        entries = obs.takeRecords ? obs.takeRecords() : [];
      } catch (e) {
        entries = [];
      }
      if (!entries || !entries.length) return;
      entries.forEach(function(entry) {
        if (!entry) return;
        const card = entry.target;
        if (!card || !card.dataset) return;
        const item = state.items.byId.get(card.dataset.id);
        if (!item) return;
        if (!entry.isIntersecting && entry.intersectionRatio <= 0) {
          item.__thumbInView = 0;
          return;
        }
        const gridRect = resolveIoGridRect(entry);
        const inView = gridRect ? isEntryInGridView(entry, gridRect) : !!entry.isIntersecting;
        item.__thumbInView = inView ? 1 : 0;
        thumbEnqueue(item, inView);
      });
    });
  };
  state.thumb.scanNow = schedule;

  if (typeof IntersectionObserver === 'function') {
    try {
      state.thumb.observer = new IntersectionObserver(function(entries) {
        entries.forEach(function(entry) {
          if (!entry) return;
          const card = entry.target;
          if (!card || !card.dataset) return;
          const item = state.items.byId.get(card.dataset.id);
          if (!item) return;
          if (!entry.isIntersecting && entry.intersectionRatio <= 0) {
            item.__thumbInView = 0;
            return;
          }
          const gridRect = resolveIoGridRect(entry);
          const inView = gridRect ? isEntryInGridView(entry, gridRect) : !!entry.isIntersecting;
          item.__thumbInView = inView ? 1 : 0;
          thumbEnqueue(item, inView);
        });
      }, {
        root: root,
        rootMargin: '0px 0px',
        threshold: 0.01
      });
      Array.from(root.querySelectorAll('.card')).forEach(function(card) {
        try { state.thumb.observer.observe(card); } catch (e) {}
      });
    } catch (e) {
      state.thumb.observer = null;
    }
  }
  if (state.thumb.observer) {
    state.thumb.scanNow = kickScanNow;
  }

  const resumeFromScroll = function() {
    if (!state.thumb) return;
    state.thumb.scrollResumeTimer = 0;
    const now = Date.now();
    const until = state.thumb.scrollPauseUntil || 0;
    if (until > now) {
      state.thumb.scrollResumeTimer = setTimeout(resumeFromScroll, until - now);
      return;
    }
    state.thumb.pausedByScroll = false;
    if (state.ui && state.ui.__infoDirty) {
      state.ui.__infoDirty = false;
      updateInfo();
    }

    // スクロール中に溜めたUI反映を分割で実行
    try { thumbFlushUiQueue(); } catch (e) {}

    // ロード再開
    thumbPump();
  };

  const markScrollPause = function() {
    if (!state.thumb) return;
    state.thumb.pausedByScroll = true;
    state.thumb.scrollPauseUntil = Date.now() + (state.cfg.thumbScrollPauseMs || 0);
    if (state.thumb.scrollResumeTimer) {
      clearTimeout(state.thumb.scrollResumeTimer);
      state.thumb.scrollResumeTimer = 0;
    }
    state.thumb.scrollResumeTimer = setTimeout(resumeFromScroll, state.cfg.thumbScrollResumeMs || 0);
  };

  const scheduleScrollEndScan = function() {
    if (!state.thumb) return;

    // IntersectionObserverがあるなら、スクロール停止ごとの総当たりスキャンはやらない（ガクつき対策）
    if (state.thumb.observer) return;

    if (state.thumb.scrollEndScanTimer) {
      clearTimeout(state.thumb.scrollEndScanTimer);
      state.thumb.scrollEndScanTimer = 0;
    }
    state.thumb.scrollEndScanTimer = setTimeout(function() {
      state.thumb.scrollEndScanTimer = 0;
      schedule();
    }, state.cfg.thumbScrollEndScanMs || 0);
  };

  const onScroll = function() {
    markScrollPause();
    scheduleScrollEndScan();
  };

  if (state.thumb.onScroll) {
    try { root.removeEventListener('scroll', state.thumb.onScroll); } catch (e) {}
  }
  state.thumb.onScroll = onScroll;
  root.addEventListener('scroll', state.thumb.onScroll, { passive: true });

  if (state.thumb.onResize) {
    try { window.removeEventListener('resize', state.thumb.onResize); } catch (e) {}
  }
  state.thumb.onResize = function() {
    if (state.thumb && typeof state.thumb.scanNow === 'function') state.thumb.scanNow();
  };
  window.addEventListener('resize', state.thumb.onResize);
  if (state.thumb.observer) {
    if (typeof state.thumb.scanNow === 'function') state.thumb.scanNow();
  } else {
    schedule();
  }
}

function observeThumbCard(card) {
  if (!card || !state.thumb) return;
  if (state.thumb.observer) {
    try { state.thumb.observer.observe(card); } catch (e) {}
  } else if (state.thumb && typeof state.thumb.scanNow === 'function') {
    state.thumb.scanNow();
  }
}

function thumbQueueLength() {
  if (!state.thumb) return 0;
  const pri = Math.max(0, (state.thumb.queuePri.length || 0) - (state.thumb.queuePriHead || 0));
  const normal = Math.max(0, (state.thumb.queue.length || 0) - (state.thumb.queueHead || 0));
  return pri + normal;
}

function compactThumbQueue(name) {
  if (!state.thumb) return;
  const queueKey = name === 'pri' ? 'queuePri' : 'queue';
  const headKey = name === 'pri' ? 'queuePriHead' : 'queueHead';
  const q = state.thumb[queueKey];
  const head = state.thumb[headKey] || 0;
  if (!q || !q.length) {
    state.thumb[headKey] = 0;
    return;
  }
  if (head > 64 && head * 2 >= q.length) {
    state.thumb[queueKey] = q.slice(head);
    state.thumb[headKey] = 0;
  }
}

function pushThumbQueue(item, priority) {
  if (!state.thumb || !item) return;
  if (priority) {
    state.thumb.queuePri.push(item);
    item.__thumbQueuedPri = 1;
  } else {
    state.thumb.queue.push(item);
    item.__thumbQueuedPri = 0;
  }
}

function popThumbQueue() {
  if (!state.thumb) return null;
  let item = null;
  while (state.thumb.queuePriHead < state.thumb.queuePri.length) {
    item = state.thumb.queuePri[state.thumb.queuePriHead++];
    if (item) break;
    item = null;
  }
  compactThumbQueue('pri');
  if (item) return item;
  while (state.thumb.queueHead < state.thumb.queue.length) {
    item = state.thumb.queue[state.thumb.queueHead++];
    if (item) break;
    item = null;
  }
  compactThumbQueue('normal');
  return item;
}

function promoteQueuedThumbItem(item) {
  if (!state.thumb || !item) return;
  if (item.__thumbQueuedPri === 1) return;
  pushThumbQueue(item, true);
}

function requeueThumbItem(item) {
  if (!state.thumb || !item) return;
  pushThumbQueue(item, item.__thumbQueuedPri === 1);
}

function thumbSchedulePump() {
  if (!state.thumb) return;
  if (state.thumb.pumpScheduled) return;
  state.thumb.pumpScheduled = true;
  requestAnimationFrame(function() {
    if (!state.thumb) return;
    state.thumb.pumpScheduled = false;
    thumbPump();
  });
}

function thumbEnqueue(item, priority) {
  if (!item) return;
  const canLoad = (item.kind === 'img') || !!item.__thumbPreview;
  if (!canLoad) return;
  if (!item.card) return;
  let img = item.__thumbImg;
  if (!img || !img.isConnected) {
    img = item.card.querySelector('img[data-src]');
    if (img) item.__thumbImg = img;
  }
  if (!img) return;
  if (item.__failed || item.__thumbLoaded || item.__thumbLoading) return;
  if (!state.thumb) return;
  const pri = !!priority;
  if (state.thumb.queued.has(item.id)) {
    if (pri) promoteQueuedThumbItem(item);
    thumbSchedulePump();
    return;
  }
  state.thumb.queued.add(item.id);
  pushThumbQueue(item, pri);
  markThumbProgress();
  thumbSchedulePump();
}

function thumbPump() {
  if (!state.thumb || state.thumb.paused) return;
  const prevMax = state.thumb.max || 0;
  const baseMax = getThumbMaxConcurrent() || 0;
  let max = baseMax;
  if (state.thumb.pausedByScroll) {
    const scrollMax = getThumbMaxConcurrentWhileScroll();
    max = max ? Math.min(max, scrollMax) : scrollMax;
  }
  state.thumb.max = max;
  if (state.env && state.env.isIPhone) {
    const base = state.cfg.thumbConcurrentIphone || 3;
    if (max && max < base && max !== prevMax) {
      if (state.log && state.log.push) {
        state.log.push('thumb', 'throttle max=' + max + ' items=' + state.items.list.length);
      }
    }
  }
  if (!max) return;

  if (!state.thumb.pausedByScroll) {
    while (state.thumb.inFlight < max && thumbQueueLength()) {
      const item = popThumbQueue();
      if (!item) continue;
      state.thumb.queued.delete(item.id);
      item.__thumbQueuedPri = 0;
      if (item.__failed || item.__thumbLoaded || item.__thumbLoading) continue;
      startThumbLoad(item);
    }
    return;
  }

  const hasIO = !!state.thumb.observer;
  let gridRect = null;
  if (!hasIO) {
    const grid = state.ui ? state.ui.grid : null;
    if (!grid || typeof grid.getBoundingClientRect !== 'function') return;
    gridRect = grid.getBoundingClientRect();
  }
  const probeLimit = 24;
  for (let i = 0; i < probeLimit && state.thumb.inFlight < max && thumbQueueLength(); i++) {
    const item = popThumbQueue();
    if (!item) continue;
    if (item.__failed || item.__thumbLoaded || item.__thumbLoading) {
      state.thumb.queued.delete(item.id);
      item.__thumbQueuedPri = 0;
      continue;
    }
    if (!item.card) {
      state.thumb.queued.delete(item.id);
      item.__thumbQueuedPri = 0;
      continue;
    }
    if (hasIO) {
      if (!item.__thumbInView) {
        requeueThumbItem(item);
        continue;
      }
    } else if (!isCardInGridView(item.card, gridRect)) {
      requeueThumbItem(item);
      continue;
    }
    state.thumb.queued.delete(item.id);
    item.__thumbQueuedPri = 0;
    startThumbLoad(item);
  }
}

function addRetryBuster(url, n) {
  const retry = Number(n) || 0;
  if (!url || retry < 1) return url;
  try {
    const u = new URL(url, location.href);
    if (!(u.protocol === 'http:' || u.protocol === 'https:')) return url;
    u.searchParams.set('__ivb_retry', String(retry));
    return u.toString();
  } catch (e) {}
  try {
    const raw = String(url);
    const hashPos = raw.indexOf('#');
    const hash = hashPos >= 0 ? raw.slice(hashPos) : '';
    const base = hashPos >= 0 ? raw.slice(0, hashPos) : raw;
    const sep = base.indexOf('?') >= 0 ? '&' : '?';
    return base + sep + '__ivb_retry=' + encodeURIComponent(String(retry)) + hash;
  } catch (e) {}
  return url;
}

function resolveLoadedSrc(raw) {
  if (!raw) return '';
  try {
    return new URL(String(raw), location.href).toString();
  } catch (e) {
    return String(raw);
  }
}

function isSameLoadedSrc(currentSrc, targetSrc) {
  if (!currentSrc || !targetSrc) return false;
  return resolveLoadedSrc(currentSrc) === resolveLoadedSrc(targetSrc);
}

function startThumbLoad(item) {
  if (!item || !item.card) return;
  const card = item.card;
  let img = item.__thumbImg;
  if (!img || !img.isConnected) {
    img = card.querySelector('img');
    if (img) item.__thumbImg = img;
  }
  if (!img) return;
  const previewOnly = item.kind !== 'img';
  const src = img.dataset && img.dataset.src ? img.dataset.src : getDisplayUrl(item);
  if (!src) return;
  const token = (item.__thumbToken = (item.__thumbToken || 0) + 1);
  const ctx = { token: token, aborted: false, abort: null };
  item.__thumbCtx = ctx;
  item.__thumbLoading = true;
  state.thumb.inFlight += 1;
  markThumbProgress();
  const overlay = showThumbOverlay(card, 'LOADING');
  const getOverlayDelay = function() {
    const shownSrc = (img.currentSrc || img.src || '');
    const visible = img.style.opacity !== '0' && shownSrc && !isSameLoadedSrc(shownSrc, BLANK_GIF);
    return visible ? 260 : 120;
  };
  const shownSrc = (img.currentSrc || img.src || '');
  const keepVisibleOnReload = !!(
    item.__thumbLoaded &&
    isSameLoadedSrc(shownSrc, src) &&
    img.style.opacity !== '0' &&
    !isSameLoadedSrc(shownSrc, BLANK_GIF)
  );
  scheduleOverlayShow(item, overlay, getOverlayDelay());
  if (!keepVisibleOnReload) img.style.opacity = '0';

  let retries = item.__thumbRetry || 0;
  let done = false;
  let timer = 0;

  const isCurrent = function() {
    return item.__thumbCtx && item.__thumbCtx.token === token;
  };

  const finish = function() {
    if (done) return;
    const current = isCurrent();
    done = true;
    clearOverlayShowTimer(item);
    if (timer) clearTimeout(timer);
    if (current || !item.__thumbCtx) {
      item.__thumbLoading = false;
    }
    state.thumb.queued.delete(item.id);
    state.thumb.inFlight = Math.max(0, state.thumb.inFlight - 1);
    markThumbProgress();
    if (current && item.__thumbCtx && item.__thumbCtx.token === token) {
      item.__thumbCtx = null;
    }
    thumbPump();
  };

  ctx.abort = function(reason) {
    if (done) return;
    ctx.aborted = true;
    clearOverlayShowTimer(item);
    if (isCurrent()) {
      img.onload = null;
      img.onerror = null;
      hideThumbOverlay(card);
    }
    finish();
  };

  const finalizeSuccess = function() {
    if (!item.__thumbCtx || item.__thumbCtx.token !== token) {
      finish();
      return;
    }
    const pendingRefresh = !!item.__thumbPendingRefresh;
    item.__thumbPendingRefresh = 0;
    item.__thumbLoaded = true;
    finish();
    if (pendingRefresh && item.card && !item.__failed) {
      updateCard(item);
    }
    if (item.__thumbCtx && item.__thumbCtx.token === token) item.__thumbCtx = null;
  };

  const failFinal = function() {
    if (!item.__thumbCtx || item.__thumbCtx.token !== token) {
      finish();
      return;
    }
    if (previewOnly) {
      clearOverlayShowTimer(item);
      item.__thumbLoaded = true;
      hideThumbOverlay(card);
      finish();
      if (item.__thumbCtx && item.__thumbCtx.token === token) item.__thumbCtx = null;
      return;
    }
    clearOverlayShowTimer(item);
    state.items.errorCount += 1;
    item.__failed = true;
    try {
      if (state.thumb && state.thumb.observer) {
        try { state.thumb.observer.unobserve(card); } catch (e) {}
      }
      if (card.parentNode) card.parentNode.removeChild(card);
    } catch (e) {}
    item.card = null;
    applyErrorVis();
    finish();
    if (item.__thumbCtx && item.__thumbCtx.token === token) item.__thumbCtx = null;
  };

  const scheduleRetry = function() {
    if (done) return;
    if (!item.__thumbCtx || item.__thumbCtx.token !== token) {
      finish();
      return;
    }
    clearOverlayShowTimer(item);
    retries += 1;
    item.__thumbRetry = retries;
    img.onload = null;
    img.onerror = null;
    setTimeout(function() {
      if (done) return;
      attempt();
    }, state.cfg.thumbRetryDelayMs || 0);
  };

  const attempt = function() {
    if (done) return;
    if (!item.__thumbCtx || item.__thumbCtx.token !== token) {
      finish();
      return;
    }
    if (timer) clearTimeout(timer);
    item.__thumbStartedAt = Date.now();
    const targetSrc = retries > 0 ? addRetryBuster(src, retries) : src;
    scheduleOverlayShow(item, overlay, getOverlayDelay());
    img.onload = function() {
      if (done) return;
      if (!item.__thumbCtx || item.__thumbCtx.token !== token) {
        finish();
        return;
      }
      if (!isSameLoadedSrc((img.currentSrc || img.src), targetSrc)) return;
      if (!previewOnly) applyThumbMetrics(item, img, card);
      const show = function() {
        if (done) return;
        if (!item.__thumbCtx || item.__thumbCtx.token !== token) {
          finish();
          return;
        }
        clearOverlayShowTimer(item);
        revealThumb(card, img);
        finalizeSuccess();
      };
      const settleAfterReady = function() {
        if (done) return;
        if (!item.__thumbCtx || item.__thumbCtx.token !== token) {
          finish();
          return;
        }
        if (!isSameLoadedSrc((img.currentSrc || img.src), targetSrc)) return;
        if (timer) clearTimeout(timer);
        const nw = img.naturalWidth || 0;
        const nh = img.naturalHeight || 0;
        if (!nw || !nh) {
          markThumbProgress();
          if (state.log && state.log.push) state.log.push('thumb', 'dim0 retry');
          if (retries < (state.cfg.thumbRetryMax || 0)) {
            scheduleRetry();
          } else {
            failFinal();
          }
          return;
        }
        show();
      };
      if (shouldSkipThumbDecode() || (state.thumb && state.thumb.pausedByScroll)) {
        requestAnimationFrame(function() {
          settleAfterReady();
        });
      } else {
        decodeWithTimeout(img, state.cfg.decodeTimeoutMsThumb || 0).then(function() {
          settleAfterReady();
        });
      }
    };
    img.onerror = function() {
      if (done) return;
      if (!item.__thumbCtx || item.__thumbCtx.token !== token) {
        finish();
        return;
      }
      markThumbProgress();
      if (timer) clearTimeout(timer);
      if (retries < (state.cfg.thumbRetryMax || 0)) {
        scheduleRetry();
      } else {
        failFinal();
      }
    };
    timer = setTimeout(function() {
      if (done) return;
      if (!item.__thumbCtx || item.__thumbCtx.token !== token) {
        finish();
        return;
      }
      markThumbProgress();
      if (retries < (state.cfg.thumbRetryMax || 0)) {
        scheduleRetry();
      } else {
        failFinal();
      }
    }, state.cfg.thumbTimeoutMs || 0);
    try { img.src = targetSrc; } catch (e) { img.src = targetSrc; }
  };

  attempt();
}

function getMediaBadgeInfo(item) {
  if (!item) return null;
  if (item.kind === 'video') {
    return { text: '▶', full: 'VIDEO' };
  }
  if (item.kind === 'embed' || item.embedType) {
    const t = ((item.embedType || '').toUpperCase()) || 'OTHER';
    let text = '?';
    if (t === 'X' || t === 'TT' || t === 'YT') text = t;
    else if (t === 'INSTA') text = 'IG';
    else if (t === 'IMGUR') text = 'IM';
    return { text: text, full: t };
  }
  return null;
}

function createCard(item) {
  const card = document.createElement('div');
  card.className = 'card';
  card.dataset.id = item.id;
  card.dataset.kind = item.kind || '';
  card.dataset.oh = item.__allHidden ? '1' : '0';
  if (item.embedType) {
    card.dataset.etype = ((item.embedType || '').toUpperCase()) || 'OTHER';
  }
  const th = (state.env && state.env.isWide) ? 180 : 140;
  card.style.minHeight = (th + 40) + 'px';

  const thumb = document.createElement('button');
  thumb.className = 'thumb';
  if (item.kind === 'video' || item.kind === 'embed') thumb.classList.add('is-playable');
  const hlabel = document.createElement('div');
  hlabel.className = 'hlabel';
  hlabel.textContent = '非表示';
  thumb.appendChild(hlabel);

  item.__thumbPreview = false;
  let needsThumbOverlay = false;
  const appendThumbImage = function(src, overlayMode) {
    if (!src) return null;
    const img = document.createElement('img');
    img.decoding = 'async';
    img.src = BLANK_GIF;
    img.dataset.src = src;
    img.alt = '';
    img.style.display = 'block';
    img.style.width = '100%';
    img.style.height = th + 'px';
    img.style.objectFit = 'contain';
    img.style.objectPosition = 'center';
    img.style.background = '#000';
    img.style.opacity = '0';
    if (overlayMode) {
      img.style.position = 'absolute';
      img.style.left = '0';
      img.style.top = '0';
    }
    thumb.appendChild(img);
    item.__thumbImg = img;
    needsThumbOverlay = true;
    return img;
  };

  if (item.kind === 'img') {
    const displayUrl = getDisplayUrl(item);
    appendThumbImage(displayUrl, false);
    const badgeInfo = getMediaBadgeInfo(item);
    if (badgeInfo) {
      const badge = document.createElement('div');
      badge.className = 'badge';
      badge.textContent = badgeInfo.text;
      badge.title = badgeInfo.full;
      badge.setAttribute('aria-label', badgeInfo.full);
      thumb.appendChild(badge);
    }
  } else if (item.kind === 'video') {
    const ph = document.createElement('div');
    ph.className = 'ph';
    ph.textContent = 'VIDEO';
    ph.style.height = th + 'px';
    ph.style.width = '100%';
    thumb.appendChild(ph);
    const badge = document.createElement('div');
    badge.className = 'badge';
    const badgeInfo = getMediaBadgeInfo(item);
    badge.textContent = badgeInfo ? badgeInfo.text : '▶';
    badge.title = badgeInfo ? badgeInfo.full : 'VIDEO';
    badge.setAttribute('aria-label', badgeInfo ? badgeInfo.full : 'VIDEO');
    thumb.appendChild(badge);
    if (item.poster) {
      appendThumbImage(item.poster, true);
      item.__thumbPreview = true;
    }
  } else if (item.kind === 'embed') {
    const ph = document.createElement('div');
    ph.className = 'ph';
    ph.textContent = 'TAP FOR LB ' + item.embedType;
    ph.style.height = th + 'px';
    ph.style.width = '100%';
    thumb.appendChild(ph);
    const badge = document.createElement('div');
    badge.className = 'badge';
    const badgeInfo = getMediaBadgeInfo(item);
    badge.textContent = badgeInfo ? badgeInfo.text : '?';
    badge.title = badgeInfo ? badgeInfo.full : (((item.embedType || '').toUpperCase()) || 'OTHER');
    badge.setAttribute('aria-label', badgeInfo ? badgeInfo.full : (((item.embedType || '').toUpperCase()) || 'OTHER'));
    thumb.appendChild(badge);
    const embedThumbUrl = getEmbedThumbUrl(item);
    if (embedThumbUrl) {
      appendThumbImage(embedThumbUrl, true);
      item.__thumbPreview = true;
    }
  }

  const meta = document.createElement('div');
  meta.className = 'meta';
  const page = document.createElement('span');
  page.className = 'chip-page';
  page.textContent = item.pageLabel || 'P1';
  const dim = document.createElement('div');
  dim.textContent = formatItemMetaText(item);
  if (item.kind === 'embed') {
    const inlineBtn = document.createElement('button');
    inlineBtn.className = 'inline';
    inlineBtn.textContent = 'IN';
    inlineBtn.addEventListener('click', function(ev) {
      ev.preventDefault();
      ev.stopPropagation();
      buildEmbedInCard(card, item);
      boostCrawl('embed');
    });
    meta.appendChild(inlineBtn);
  }
  const open = document.createElement('a');
  open.className = 'open';
  open.textContent = '↗';
  open.href = allowOpen(item.openUrl) ? item.openUrl : item.url;
  open.addEventListener('click', function(ev) {
    ev.preventDefault();
    ev.stopPropagation();
    openExternal(open.href, 'card');
  });
  meta.appendChild(page);
  meta.appendChild(dim);
  meta.appendChild(open);

  let thumbLastTouchLikeTs = 0;
  let thumbIgnoreClickUntil = 0;
  let thumbTouchActive = false;
  let thumbTouchId = -1;
  let thumbTouchMoved = false;
  let thumbStartX = 0;
  let thumbStartY = 0;
  let thumbStartGridScrollTop = 0;
  let thumbStartWindowScrollY = 0;
  const thumbTapMoveThresholdPx = 8;
  const thumbScrollMoveThresholdPx = 4;
  const readGridScrollTop = function() {
    const gridEl = state.ui && state.ui.grid;
    return gridEl ? (gridEl.scrollTop || 0) : 0;
  };
  const readWindowScrollY = function() {
    return window.pageYOffset || document.documentElement.scrollTop || 0;
  };
  const findTouchById = function(list, id) {
    if (!list || !Number.isFinite(id)) return null;
    for (let i = 0; i < list.length; i++) {
      const t = list[i];
      if (t && t.identifier === id) return t;
    }
    return null;
  };
  const markTouchMovedByPoint = function(x, y) {
    if (!thumbTouchActive) return;
    if (!Number.isFinite(x) || !Number.isFinite(y)) return;
    if (Math.abs(x - thumbStartX) > thumbTapMoveThresholdPx || Math.abs(y - thumbStartY) > thumbTapMoveThresholdPx) {
      thumbTouchMoved = true;
    }
  };
  const markTouchMovedByScroll = function() {
    if (!thumbTouchActive) return false;
    if (Math.abs(readGridScrollTop() - thumbStartGridScrollTop) > thumbScrollMoveThresholdPx) return true;
    if (Math.abs(readWindowScrollY() - thumbStartWindowScrollY) > thumbScrollMoveThresholdPx) return true;
    return false;
  };
  const clearThumbTouchTrack = function() {
    window.removeEventListener('touchmove', onThumbTouchMoveCapture, true);
    window.removeEventListener('touchend', onThumbTouchEndCapture, true);
    window.removeEventListener('touchcancel', onThumbTouchCancelCapture, true);
    thumbTouchActive = false;
    thumbTouchId = -1;
    thumbTouchMoved = false;
    thumbStartX = 0;
    thumbStartY = 0;
    thumbStartGridScrollTop = 0;
    thumbStartWindowScrollY = 0;
  };
  const onThumbTouchMoveCapture = function(ev) {
    if (!thumbTouchActive) return;
    const t = findTouchById(ev.touches, thumbTouchId) || findTouchById(ev.changedTouches, thumbTouchId);
    if (!t) return;
    markTouchMovedByPoint(t.clientX, t.clientY);
    if (markTouchMovedByScroll()) thumbTouchMoved = true;
  };
  const onThumbTouchEndCapture = function(ev) {
    if (!thumbTouchActive) return;
    const t = findTouchById(ev.changedTouches, thumbTouchId);
    if (!t) return;
    markTouchMovedByPoint(t.clientX, t.clientY);
    if (markTouchMovedByScroll()) thumbTouchMoved = true;
    const moved = thumbTouchMoved;
    const now = Date.now();
    thumbLastTouchLikeTs = now;
    thumbIgnoreClickUntil = now + 520;
    clearThumbTouchTrack();
    if (moved) return;
    try { ev.preventDefault(); } catch (e) {}
    openLightboxById(item.id);
  };
  const onThumbTouchCancelCapture = function() {
    if (!thumbTouchActive) return;
    thumbIgnoreClickUntil = Date.now() + 520;
    clearThumbTouchTrack();
  };
  thumb.addEventListener('touchstart', function(ev) {
    const t = ev.changedTouches && ev.changedTouches[0];
    if (!t) return;
    clearThumbTouchTrack();
    thumbTouchActive = true;
    thumbTouchId = t.identifier;
    thumbTouchMoved = false;
    thumbStartX = t.clientX;
    thumbStartY = t.clientY;
    thumbStartGridScrollTop = readGridScrollTop();
    thumbStartWindowScrollY = readWindowScrollY();
    window.addEventListener('touchmove', onThumbTouchMoveCapture, { capture: true, passive: true });
    window.addEventListener('touchend', onThumbTouchEndCapture, { capture: true, passive: false });
    window.addEventListener('touchcancel', onThumbTouchCancelCapture, { capture: true, passive: true });
  }, { passive: true });
  thumb.addEventListener('click', function(ev) {
    const now = Date.now();
    if (now < thumbIgnoreClickUntil || (now - thumbLastTouchLikeTs) < 450) {
      ev.preventDefault();
      return;
    }
    ev.preventDefault();
    openLightboxById(item.id);
  });

  card.appendChild(thumb);
  if (needsThumbOverlay) showThumbOverlay(card, 'LOADING');
  card.appendChild(meta);
  const dup = document.createElement('div');
  dup.className = 'dup-badge';
  card.appendChild(dup);
  item.card = card;
  updateDupBadge(item);
  item.__renderUrl = (item.kind === 'img') ? getDisplayUrl(item) : item.url;
  return card;
}

function updateCard(item) {
  if (!item.card) return;
  item.card.dataset.kind = item.kind || '';
  item.card.dataset.oh = item.__allHidden ? '1' : '0';
  if (item.embedType) {
    item.card.dataset.etype = ((item.embedType || '').toUpperCase()) || 'OTHER';
  } else {
    item.card.removeAttribute('data-etype');
  }
  const thumbBtn = item.card.querySelector('.thumb');
  if (thumbBtn) {
    const playable = (item.kind === 'video' || item.kind === 'embed') && !thumbBtn.querySelector('iframe');
    thumbBtn.classList.toggle('is-playable', playable);
  }
  let mediaBadge = item.card.querySelector('.thumb .badge');
  if (!mediaBadge) {
    const badgeInfo = getMediaBadgeInfo(item);
    if (badgeInfo && thumbBtn) {
      mediaBadge = document.createElement('div');
      mediaBadge.className = 'badge';
      mediaBadge.textContent = badgeInfo.text;
      mediaBadge.title = badgeInfo.full;
      mediaBadge.setAttribute('aria-label', badgeInfo.full);
      thumbBtn.appendChild(mediaBadge);
    }
  }
  if (mediaBadge) {
    const badgeInfo = getMediaBadgeInfo(item);
    if (badgeInfo) {
      mediaBadge.textContent = badgeInfo.text;
      mediaBadge.title = badgeInfo.full;
      mediaBadge.setAttribute('aria-label', badgeInfo.full);
    }
  }
  let img = item.__thumbImg;
  if (!img || !img.isConnected) {
    img = item.card.querySelector('img');
    if (img) item.__thumbImg = img;
  }
  const displayUrl = getDisplayUrl(item);
  const shownSrc = img ? (img.currentSrc || img.src || '') : '';
  const requestedSrc = (img && img.dataset) ? (img.dataset.src || '') : '';
  const sameShownAsDisplay = !!(shownSrc && isSameImageVariantUrl(shownSrc, displayUrl));
  const sameRequestedAsDisplay = !!(requestedSrc && isSameImageVariantUrl(requestedSrc, displayUrl));
  const urlChanged = !!(item.__renderUrl && !isSameImageVariantUrl(item.__renderUrl, displayUrl));
  const loadingWithSwitch = !!(item.__thumbLoading && !sameRequestedAsDisplay && urlChanged);
  if (loadingWithSwitch) item.__thumbPendingRefresh = 1;
  const keepCurrentLoad = !!(item.__thumbLoading && (sameRequestedAsDisplay || loadingWithSwitch));
  const needReload = !!(img && !keepCurrentLoad && !sameShownAsDisplay &&
    (urlChanged || !item.__thumbLoaded || isSameLoadedSrc(shownSrc, BLANK_GIF)));
  if (img && item.kind === 'img') {
    img.dataset.src = displayUrl;
  }
  if (img && item.kind === 'img' && needReload) {
    try {
      if (item.__thumbLoading && item.__thumbCtx && typeof item.__thumbCtx.abort === 'function') {
        item.__thumbCtx.abort('updateCard');
      }
    } catch (e) {}
    item.__thumbCtx = null;
    img.src = BLANK_GIF;
    img.style.opacity = '0';
    item.__thumbLoaded = false;
    item.__thumbLoading = false;
    item.__thumbRetry = 0;
    showThumbOverlay(item.card, 'LOADING');
    thumbEnqueue(item);
  }
  const page = item.card.querySelector('.chip-page');
  if (page) page.textContent = item.pageLabel || 'P1';
  const dim = item.card.querySelector('.meta div');
  if (dim) dim.textContent = formatItemMetaText(item);
  const open = item.card.querySelector('a.open');
  if (open) open.href = allowOpen(item.openUrl) ? item.openUrl : item.url;
  updateDupBadge(item);
  item.__renderUrl = displayUrl;
}

function updateDupBadge(item) {
  if (!item.card) return;
  let badge = item.card.querySelector('.dup-badge');
  if (!badge) {
    badge = document.createElement('div');
    badge.className = 'dup-badge';
    item.card.appendChild(badge);
  }
  if (!badge.__dupClickBound) {
    badge.__dupClickBound = true;
    badge.addEventListener('click', function(ev) {
      ev.preventDefault();
      ev.stopPropagation();
      const info = badge.dataset.info || badge.title || '';
      if (!info) return;
      if (navigator.clipboard && typeof navigator.clipboard.writeText === 'function') {
        navigator.clipboard.writeText(info).then(function() {
          if (typeof setInfoTemp === 'function') setInfoTemp('DUP DETAIL', 700);
        }).catch(function() {
          try { prompt('DUP DETAIL (copy)', info); } catch (e) {}
          if (typeof setInfoTemp === 'function') setInfoTemp('DUP DETAIL', 700);
        });
      } else {
        try { prompt('DUP DETAIL (copy)', info); } catch (e) {}
        if (typeof setInfoTemp === 'function') setInfoTemp('DUP DETAIL', 700);
      }
    });
  }
  if (item.dupCount >= 2) {
    addDupClusterUrl(item, item.url || item.abs || '');
    const hostCounts = getDupClusterHostCounts(item);
    const hostCount = Object.keys(hostCounts).length;
    badge.textContent = hostCount >= 2 ? ('×' + item.dupCount + ' H' + hostCount) : ('×' + item.dupCount);
    const detail = buildDupClusterDetail(item, 8);
    badge.title = detail;
    badge.dataset.info = detail;
    badge.style.display = 'block';
  } else {
    badge.title = '';
    badge.dataset.info = '';
    badge.style.display = 'none';
  }
}

/* [12] lightbox */
function createLightbox() {
  const lb = document.createElement('div');
  lb.className = 'lb';
  lb.style.setProperty('z-index', '2', 'important');
  lb.style.setProperty('pointer-events', 'auto', 'important');
  function bindLbTap(el, handler) {
    if (!el || typeof handler !== 'function') return;
    let lastTouchLikeTs = 0;
    let lastNonClickTs = 0;
    const onTap = function(ev) {
      const now = Date.now();
      if (ev.type === 'click' && (now - lastTouchLikeTs) < 450) {
        try { ev.preventDefault(); } catch (e) {}
        return;
      }
      if (ev.type !== 'click') {
        if ((now - lastNonClickTs) < 120) {
          try { ev.preventDefault(); } catch (e) {}
          return;
        }
        lastNonClickTs = now;
        lastTouchLikeTs = now;
        try { ev.preventDefault(); } catch (e) {}
      }
      handler(ev);
    };
    el.addEventListener('click', onTap);
    el.addEventListener('pointerup', onTap);
    el.addEventListener('touchend', onTap, { passive: false });
  }
  const frame = document.createElement('div');
  frame.className = 'lb-frame';
  const badge = document.createElement('div');
  badge.className = 'lb-badge';
  badge.textContent = '';
  badge.style.display = 'none';
  if (!badge.__lbClickBound) {
    badge.__lbClickBound = true;
    badge.addEventListener('click', function(ev) {
      ev.preventDefault();
      ev.stopPropagation();
      const info = badge.dataset.info || badge.title || '';
      if (!info) return;
      if (navigator.clipboard && typeof navigator.clipboard.writeText === 'function') {
        navigator.clipboard.writeText(info).then(function() {
          if (typeof setInfoTemp === 'function') setInfoTemp('DETAIL', 700);
        }).catch(function() {
          try { prompt('VIDEO FAIL info (copy)', info); } catch (e) {}
          if (typeof setInfoTemp === 'function') setInfoTemp('DETAIL', 700);
        });
      } else {
        try { prompt('VIDEO FAIL info (copy)', info); } catch (e) {}
        if (typeof setInfoTemp === 'function') setInfoTemp('DETAIL', 700);
      }
    });
  }
  frame.appendChild(badge);
  const controls = document.createElement('div');
  controls.className = 'lb-controls';
  const prevBtn = mkBtn('Prev', 'lb-btn');
  const nextBtn = mkBtn('Next', 'lb-btn');
  const closeBtn = mkBtn('Close', 'lb-btn');
  const openBtn = mkBtn('↗', 'lb-btn');
  controls.appendChild(prevBtn);
  controls.appendChild(nextBtn);
  controls.appendChild(openBtn);
  controls.appendChild(closeBtn);

  lb.appendChild(frame);
  lb.appendChild(controls);
  state.ui.wrap.appendChild(lb);

  bindLbTap(prevBtn, function(ev) {
    ev.preventDefault();
    moveLightbox(-1);
  });
  bindLbTap(nextBtn, function(ev) {
    ev.preventDefault();
    moveLightbox(1);
  });
  bindLbTap(closeBtn, function(ev) {
    ev.preventDefault();
    closeLightbox();
  });
  bindLbTap(openBtn, function(ev) {
    ev.preventDefault();
    ev.stopPropagation();
    const it = state.lb.list[state.lb.index];
    if (it) openExternal(it.openUrl, 'lightbox');
  });
  bindLbTap(lb, function(ev) {
    if (ev.target === lb) closeLightbox();
  });

  state.lb.overlay = lb;
  state.lb.frame = frame;
  state.lb.badge = badge;
  state.lb.openBtn = openBtn;
}

function buildLightboxList() {
  const cards = Array.from(state.ui.grid.querySelectorAll('.card'))
    .filter(function(card) { return !card.classList.contains('is-hidden') && !card.classList.contains('is-error'); });
  state.lb.list = cards.map(function(card) { return state.items.byId.get(card.dataset.id); });
}

function openLightboxById(id) {
  buildLightboxList();
  const idx = state.lb.list.findIndex(function(it) { return it && it.id === id; });
  if (idx < 0) return;
  state.lb.index = idx;
  if (state.thumb) state.thumb.paused = true;
  renderLightboxItem();
  state.lb.overlay.classList.add('open');
  state.lb.open = true;
}

function moveLightbox(dir) {
  if (!state.lb.list.length) return;
  let next = state.lb.index + dir;
  if (next < 0) next = state.lb.list.length - 1;
  if (next >= state.lb.list.length) next = 0;
  state.lb.index = next;
  renderLightboxItem();
}

function clearLightboxFrame() {
  const frame = state.lb.frame;
  while (frame.childNodes.length > 1) {
    frame.removeChild(frame.lastChild);
  }
}

function renderLightboxItem() {
  const item = state.lb.list[state.lb.index];
  if (!item) return;
  if (state.lb.overlay) {
    state.lb.overlay.dataset.kind = item.kind || '';
    if (item.embedType) {
      state.lb.overlay.dataset.etype = ((item.embedType || '').toUpperCase()) || 'OTHER';
    } else {
      state.lb.overlay.removeAttribute('data-etype');
    }
  }
  const prevId = state.lb.currentId;
  if (state.wd && prevId !== item.id) {
    state.wd.lbKickCount = 0;
  }
  state.lb.currentId = item.id;
  state.lb.__loading = false;
  state.lb.__ctx = null;
  clearLightboxFrame();
  state.lb.badge.style.display = 'none';
  if (item.kind === 'video') {
    const v = document.createElement('video');
    let host = 'unknown';
    try { host = new URL(item.url || '', location.href).hostname || 'unknown'; } catch (e) {}
    const describeMediaError = function(err) {
      if (!err) return 'unknown';
      if (typeof err.message === 'string' && err.message) return err.message;
      const code = typeof err.code === 'number' ? err.code : 0;
      if (code === 1) return 'aborted';
      if (code === 2) return 'network';
      if (code === 3) return 'decode';
      if (code === 4) return 'src-not-supported';
      return code ? ('code-' + code) : 'unknown';
    };
    const escapeHtml = function(text) {
      return String(text || '')
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;');
    };
    const fallbackVideoViaSrcdoc = function(url) {
      if (!url) return;
      const frame = state.lb.frame;
      if (!frame) return;
      if (v && v.parentNode === frame) {
        frame.removeChild(v);
      } else if (v) {
        v.style.display = 'none';
      }
      const iframe = document.createElement('iframe');
      iframe.className = 'lb-embed lb-video-fallback';
      iframe.loading = 'eager';
      iframe.setAttribute('referrerpolicy', 'no-referrer');
      iframe.setAttribute('allow', 'autoplay; fullscreen; picture-in-picture');
      iframe.addEventListener('load', function() {
        item.__lbFallbackPending = false;
        markVideoSuccess();
      });
      const safeUrl = escapeHtml(url);
      iframe.srcdoc = [
        '<!doctype html><html><head>',
        '<meta charset="utf-8">',
        '<meta name="referrer" content="no-referrer">',
        '<meta name="viewport" content="width=device-width, initial-scale=1">',
        '<style>html,body{margin:0;height:100%;background:#000}video{width:100%;height:100%;object-fit:contain}</style>',
        '</head><body>',
        '<video controls playsinline webkit-playsinline preload="metadata" src="', safeUrl, '"></video>',
        '<a href="', safeUrl, '" target="_blank" rel="noopener noreferrer" style="position:fixed;bottom:6px;right:8px;color:#9cf;font-size:11px;text-decoration:none;opacity:0.7">Open</a>',
        '</body></html>'
      ].join('');
      frame.appendChild(iframe);
      item.__lbFallbackPending = true;
      clearFallbackPendingTimer();
      fallbackPendingTimer = setTimeout(function() {
        fallbackPendingTimer = 0;
        item.__lbFallbackPending = false;
        if (!videoSuccess && videoFailCandidate) {
          videoFailCandidate.explicitFinal = true;
          confirmFinalVideoFail();
        }
      }, 1200);
    };
    let videoFailTimer = 0;
    let videoFailCandidate = null;
    let videoSuccess = false;
    let noSourceTimer = 0;
    let fallbackPendingTimer = 0;
    const clearVideoFailTimer = function() {
      if (!videoFailTimer) return;
      clearTimeout(videoFailTimer);
      videoFailTimer = 0;
    };
    const clearNoSourceTimer = function() {
      if (!noSourceTimer) return;
      clearTimeout(noSourceTimer);
      noSourceTimer = 0;
    };
    const clearFallbackPendingTimer = function() {
      if (!fallbackPendingTimer) return;
      clearTimeout(fallbackPendingTimer);
      fallbackPendingTimer = 0;
    };
    const hideVideoFailBadge = function() {
      if (!state.lb.badge) return;
      state.lb.badge.style.display = 'none';
    };
    const markVideoSuccess = function() {
      if (videoSuccess) return;
      videoSuccess = true;
      videoFailCandidate = null;
      clearVideoFailTimer();
      clearNoSourceTimer();
      clearFallbackPendingTimer();
      hideVideoFailBadge();
    };
    const showVideoFail = function(info) {
      state.lb.badge.textContent = 'VIDEO FAIL\n' + info;
      state.lb.badge.title = info;
      state.lb.badge.setAttribute('aria-label', 'VIDEO FAIL ' + info);
      state.lb.badge.dataset.info = info;
      state.lb.badge.style.display = 'block';
    };
    const confirmFinalVideoFail = function() {
      if (videoSuccess) return;
      if (!videoFailCandidate) return;
      const code = (v.error && typeof v.error.code === 'number') ? v.error.code : 0;
      const net = typeof v.networkState === 'number' ? v.networkState : 0;
      const ready = typeof v.readyState === 'number' ? v.readyState : 0;
      const hasMediaError = !!v.error;
      const noSource = ready === 0 && net === 3;
      const fallbackExhausted = !videoFailCandidate.shouldFallback || !item.__lbFallbackPending;
      if (!fallbackExhausted) return;
      if (!hasMediaError && !noSource && !videoFailCandidate.explicitFinal) return;
      showVideoFail(videoFailCandidate.info);
    };
    const scheduleFinalVideoFail = function(reason) {
      const code = (v.error && typeof v.error.code === 'number') ? v.error.code : 0;
      const net = typeof v.networkState === 'number' ? v.networkState : 0;
      const ready = typeof v.readyState === 'number' ? v.readyState : 0;
      const extra = ' code=' + code + ' net=' + net + ' ready=' + ready;
      const info = host + ' / ' + (reason || 'unknown') + extra;
      const shouldFallback = host === 'video.twimg.com'
        && !item.__lbFallbackTried
        && (reason === 'src-not-supported' || (code === 4 && net === 3 && ready === 0));
      videoFailCandidate = {
        info: info,
        shouldFallback: shouldFallback,
        explicitFinal: false
      };
      if (state.log && typeof state.log.push === 'function') {
        state.log.push('warn', 'lb video error: ' + info + ' url=' + (item.url || ''));
      }
      if (shouldFallback) {
        item.__lbFallbackTried = true;
        fallbackVideoViaSrcdoc(item.url);
      }
      clearVideoFailTimer();
      videoFailTimer = setTimeout(function() {
        confirmFinalVideoFail();
      }, 1200);
    };
    v.controls = true;
    v.setAttribute('controls', '');
    v.playsInline = true;
    v.setAttribute('playsinline', '');
    v.setAttribute('webkit-playsinline', '');
    v.preload = 'metadata';
    v.setAttribute('preload', 'metadata');
    v.addEventListener('error', function() {
      clearNoSourceTimer();
      scheduleFinalVideoFail(describeMediaError(v.error));
    });
    ['loadedmetadata', 'loadeddata', 'canplay', 'playing'].forEach(function(evt) {
      v.addEventListener(evt, function() {
        markVideoSuccess();
      });
    });
    if (item.poster) v.poster = item.poster;
    state.lb.frame.appendChild(v);
    requestAnimationFrame(function() {
      v.src = item.url;
      try { v.load(); } catch (e) {}
      clearNoSourceTimer();
      noSourceTimer = setTimeout(function() {
        if (videoSuccess) return;
        if (v.readyState === 0 && v.networkState === 3) {
          scheduleFinalVideoFail('no-source');
        }
      }, 1200);
    });
    if (!item.poster) {
      renderVideoPoster(v, item);
    }
  } else if (item.kind === 'embed') {
    const iframe = document.createElement('iframe');
    iframe.className = 'lb-embed';
    applyEmbedIframeAttrs(iframe, item);
    iframe.loading = 'eager';
    const src = item.embedUrl || item.url;
    const auto = isAutoEmbedItem(item);
    iframe.addEventListener('error', function() {
      state.lb.badge.textContent = 'EMBED FAIL';
      state.lb.badge.style.display = 'block';
    });
    state.lb.frame.appendChild(iframe);
    if (src && auto) {
      const et = (item.embedType || '').toUpperCase();
      if (et === 'TT') {
        try { iframe.src = src; } catch (e) {
          state.lb.badge.textContent = 'EMBED FAIL';
          state.lb.badge.style.display = 'block';
        }
      } else {
        requestAnimationFrame(function() {
          try { iframe.src = src; } catch (e) {
            state.lb.badge.textContent = 'EMBED FAIL';
            state.lb.badge.style.display = 'block';
          }
        });
      }
    } else {
      state.lb.badge.textContent = 'EMBED FAIL';
      state.lb.badge.style.display = 'block';
    }
  } else {
    const img = document.createElement('img');
    img.alt = '';
    img.decoding = 'async';
    img.style.opacity = '0';
    const overlay = document.createElement('div');
    overlay.className = 'ph-load';
    overlay.textContent = 'LOADING';
    overlay.style.opacity = '0';
    state.lb.frame.appendChild(img);
    state.lb.frame.appendChild(overlay);
    let retries = 0;
    let done = false;
    let timer = 0;
    let overlayShowTimer = 0;
    const src = getDisplayUrl(item);
    const token = (state.lb.__token = (state.lb.__token || 0) + 1);
    const clearOverlayShowTimer = function() {
      if (!overlayShowTimer) return;
      clearTimeout(overlayShowTimer);
      overlayShowTimer = 0;
    };
    const scheduleOverlayShowLb = function(delayMs) {
      clearOverlayShowTimer();
      const wait = typeof delayMs === 'number' ? delayMs : 120;
      overlay.style.display = 'flex';
      if (overlay.style.opacity !== '1') overlay.style.opacity = '0';
      overlayShowTimer = setTimeout(function() {
        overlayShowTimer = 0;
        if (done) return;
        if (state.lb.__token !== token) return;
        if (ctx.aborted) return;
        if (!state.lb.__loading) return;
        if (!overlay || !overlay.isConnected) return;
        overlay.style.opacity = '1';
      }, wait);
    };
    const hideLbOverlay = function() {
      clearOverlayShowTimer();
      if (overlay.__hideTimer) {
        clearTimeout(overlay.__hideTimer);
        overlay.__hideTimer = 0;
      }
      if (overlay.style.opacity === '0') {
        overlay.style.display = 'none';
        return;
      }
      overlay.style.opacity = '0';
      overlay.__hideTimer = setTimeout(function() {
        overlay.__hideTimer = 0;
        overlay.style.display = 'none';
      }, 160);
    };
    const ctx = {
      token: token,
      aborted: false,
      abort: function(reason) {
        ctx.aborted = true;
        clearOverlayShowTimer();
        if (timer) {
          clearTimeout(timer);
          timer = 0;
        }
        img.onload = null;
        img.onerror = null;
        hideLbOverlay();
        if (state.lb.__token === token) state.lb.__loading = false;
      }
    };
    state.lb.__ctx = ctx;
    markLbProgress(token);
    const finish = function() {
      if (done) return;
      done = true;
      clearOverlayShowTimer();
      if (timer) clearTimeout(timer);
      if (state.lb.__token === token) {
        state.lb.__loading = false;
        state.lb.__ctx = null;
      }
    };
    const show = function() {
      if (done) return;
      if (state.lb.__token !== token) return;
      hideLbOverlay();
      img.style.opacity = '1';
      queueRepaint(img);
      if (state.env && state.env.isIOS) {
        const nudged = img.dataset ? img.dataset.fmpNudged : img.getAttribute('data-fmp-nudged');
        if (nudged !== '1') {
          if (img.dataset) img.dataset.fmpNudged = '1';
          else img.setAttribute('data-fmp-nudged', '1');
          setTimeout(function() {
            queueRepaint(img);
          }, 30);
        }
      }
      markLbProgress(token);
      finish();
    };
    const fail = function() {
      if (done) return;
      if (state.lb.__token !== token) return;
      hideLbOverlay();
      state.lb.badge.textContent = 'LOAD FAIL';
      state.lb.badge.style.display = 'block';
      markLbProgress(token);
      finish();
    };
    const scheduleRetry = function() {
      if (ctx.aborted) return;
      clearOverlayShowTimer();
      markLbProgress(token);
      retries += 1;
      img.onload = null;
      img.onerror = null;
      img.src = BLANK_GIF;
      setTimeout(function() {
        if (done) return;
        attempt();
      }, state.cfg.thumbRetryDelayMs || 0);
    };
    ctx.retry = function() {
      ctx.aborted = false;
      scheduleRetry();
    };
    const attempt = function() {
      if (done) return;
      if (state.lb.__token !== token) return;
      if (ctx.aborted) return;
      if (timer) clearTimeout(timer);
      state.lb.__loading = true;
      scheduleOverlayShowLb(120);
      markLbProgress(token);
      const targetSrc = src;
      img.onload = function() {
        if (done) return;
        if (state.lb.__token !== token) return;
        if (ctx.aborted) return;
        if (!isSameLoadedSrc((img.currentSrc || img.src), targetSrc)) return;
        decodeWithTimeout(img, state.cfg.decodeTimeoutMsLb || 0).then(function() {
          if (done) return;
          if (state.lb.__token !== token) return;
          if (ctx.aborted) return;
          if (!isSameLoadedSrc((img.currentSrc || img.src), targetSrc)) return;
          if (timer) clearTimeout(timer);
          const nw = img.naturalWidth || 0;
          const nh = img.naturalHeight || 0;
          if (!nw || !nh) {
            markLbProgress(token);
            if (state.log && state.log.push) state.log.push('lb', 'dim0 retry');
            if (retries < (state.cfg.thumbRetryMax || 0)) {
              scheduleRetry();
            } else {
              fail();
            }
            return;
          }
          show();
        });
      };
      img.onerror = function() {
        if (done) return;
        if (state.lb.__token !== token) return;
        if (ctx.aborted) return;
        if (timer) clearTimeout(timer);
        markLbProgress(token);
        if (retries < (state.cfg.thumbRetryMax || 0)) {
          scheduleRetry();
        } else {
          fail();
        }
      };
      timer = setTimeout(function() {
        if (done) return;
        if (state.lb.__token !== token) return;
        if (ctx.aborted) return;
        markLbProgress(token);
        if (retries < (state.cfg.thumbRetryMax || 0)) {
          scheduleRetry();
        } else {
          fail();
        }
      }, state.cfg.thumbTimeoutMs || 0);
      try { img.src = src; } catch (e) { img.src = src; }
    };
    attempt();
  }
  if (state.lb.openBtn) {
    state.lb.openBtn.style.display = allowOpen(item.openUrl) ? 'inline-flex' : 'none';
  }
}

function renderVideoPoster(video, item) {
  const canvas = document.createElement('canvas');
  const badge = state.lb.badge;
  let done = false;
  const fail = function() {
    if (done) return;
    done = true;
    const t = String(badge && badge.textContent || '');
    if (t.indexOf('VIDEO FAIL') === 0) return;
    badge.textContent = 'NO THUMB';
    badge.style.display = 'block';
  };
  const grab = function() {
    if (done) return;
    if ((video.readyState || 0) <= 1) {
      fail();
      return;
    }
    if (!(video.videoWidth > 0) || !(video.videoHeight > 0)) {
      fail();
      return;
    }
    try {
      canvas.width = video.videoWidth || 640;
      canvas.height = video.videoHeight || 360;
      const ctx = canvas.getContext('2d');
      if (!ctx) {
        fail();
        return;
      }
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
      try {
        const dataUrl = canvas.toDataURL('image/jpeg', 0.8);
        if (dataUrl) {
          video.setAttribute('poster', dataUrl);
          done = true;
          return;
        }
      } catch (e) {}
      fail();
    } catch (e) {
      fail();
    }
  };
  video.addEventListener('loadeddata', function() {
    setTimeout(grab, 50);
  });
  video.addEventListener('error', fail);
  setTimeout(fail, 1200);
}

function closeLightbox() {
  if (!state.lb.overlay) return;
  state.lb.overlay.classList.remove('open');
  state.lb.open = false;
  state.lb.__loading = false;
  state.lb.__ctx = null;
  if (state.wd) state.wd.lbKickCount = 0;
  clearLightboxFrame();
  if (state.thumb) {
    state.thumb.paused = false;
    thumbPump();
  }
  const id = state.lb.currentId;
  if (id && state.ui.grid) {
    const card = state.ui.grid.querySelector('.card[data-id="' + id + '"]');
    if (card && typeof card.scrollIntoView === 'function') {
      requestAnimationFrame(function() {
        try {
          card.scrollIntoView({ block: 'center', inline: 'nearest' });
          card.classList.add('is-current');
          setTimeout(function() { card.classList.remove('is-current'); }, 600);
        } catch (e) {}
      });
    }
  }
  if (typeof window.__FMP_ON_LB_CLOSE__ === 'function') {
    try { window.__FMP_ON_LB_CLOSE__(); } catch (e) {}
  }
}

/* [13] embeds */
function extractYoutubeIdFromUrl(raw) {
  if (!raw) return '';
  let u;
  try { u = new URL(raw, location.href); } catch (e) { return ''; }
  const host = (u.hostname || '').toLowerCase();
  const path = u.pathname || '';
  const isYtHost =
    host === 'youtube.com' || host.endsWith('.youtube.com') ||
    host === 'youtube-nocookie.com' || host.endsWith('.youtube-nocookie.com') ||
    host === 'youtu.be' || host.endsWith('.youtu.be');
  if (!isYtHost) return '';
  if (host === 'youtu.be' || host.endsWith('.youtu.be')) {
    const shortId = path.replace(/^\/+/, '').split(/[/?#&]/)[0] || '';
    return shortId;
  }
  const qv = u.searchParams.get('v');
  if (qv) return qv;
  const embed = /^\/embed\/([^/?#&]+)/i.exec(path);
  if (embed && embed[1]) return embed[1];
  const shorts = /^\/shorts\/([^/?#&]+)/i.exec(path);
  if (shorts && shorts[1]) return shorts[1];
  const live = /^\/live\/([^/?#&]+)/i.exec(path);
  if (live && live[1]) return live[1];
  return '';
}

function getEmbedInfo(url) {
  const x = /https?:\/\/(?:x\.com|twitter\.com|mobile\.twitter\.com)\/(?:[^/?#]+\/status\/|i\/web\/status\/|i\/status\/)(\d+)/i.exec(url);
  if (x) return { type: 'X', url: 'https://platform.twitter.com/embed/Tweet.html?id=' + x[1] };
  const ig = /https?:\/\/www\.instagram\.com\/(p|reel|tv)\/([^/?#]+)/i.exec(url);
  if (ig) return { type: 'INSTA', url: 'https://www.instagram.com/' + ig[1] + '/' + ig[2] + '/embed' };
  const ig2 = /https?:\/\/instagram\.com\/(p|reel|tv)\/([^/?#]+)/i.exec(url);
  if (ig2) return { type: 'INSTA', url: 'https://www.instagram.com/' + ig2[1] + '/' + ig2[2] + '/embed' };
  const ytId = extractYoutubeIdFromUrl(url);
  if (ytId) return { type: 'YT', url: 'https://www.youtube.com/embed/' + ytId, openUrl: url };
  const ttVideo = /https?:\/\/(?:www\.)?tiktok\.com\/@([^/?#]+)\/video\/(\d+)/i.exec(url);
  if (ttVideo) {
    return {
      type: 'TT',
      url: 'https://www.tiktok.com/player/v1/' + ttVideo[2],
      openUrl: 'https://www.tiktok.com/@' + ttVideo[1] + '/video/' + ttVideo[2]
    };
  }
  const ttEmbed = /https?:\/\/(?:www\.)?tiktok\.com\/(?:embed\/v2|player\/v1)\/(\d+)/i.exec(url);
  if (ttEmbed) {
    return {
      type: 'TT',
      url: 'https://www.tiktok.com/player/v1/' + ttEmbed[1],
      openUrl: url
    };
  }
  const im = /https?:\/\/(?:www\.)?imgur\.com\/(a|gallery)\/([^/?#]+)/i.exec(url);
  if (im) return { type: 'IMGUR', url: 'https://imgur.com/' + im[1] + '/' + im[2] + '/embed' };
  const im2 = /https?:\/\/(?:www\.)?imgur\.com\/([^/?#]+)/i.exec(url);
  if (im2) {
    const clean = (im2[1] || '').replace(/\.(?:jpe?g|png|gif|webp|bmp|avif)$/i, '');
    if (clean) {
      const openUrl = 'https://imgur.com/' + clean;
      return { type: 'IMGUR', url: openUrl + '/embed', openUrl: openUrl };
    }
  }
  return null;
}

function getEmbedInfoFromIframe(srcAbs) {
  if (!srcAbs) return null;
  let u;
  try { u = new URL(srcAbs, location.href); } catch (e) { return null; }
  const host = u.hostname.toLowerCase();
  const path = u.pathname || '';
  if (host === 'platform.twitter.com' && /\/embed\/Tweet\.html$/i.test(path)) {
    const id = u.searchParams.get('id');
    if (id) {
      return {
        type: 'X',
        embedUrl: 'https://platform.twitter.com/embed/Tweet.html?id=' + id,
        openUrl: 'https://x.com/i/web/status/' + id
      };
    }
  }
  const ytId = extractYoutubeIdFromUrl(srcAbs);
  if (ytId) {
    return {
      type: 'YT',
      embedUrl: 'https://www.youtube.com/embed/' + ytId,
      openUrl: srcAbs
    };
  }
  if (host.endsWith('instagram.com')) {
    const m = /\/(p|reel|tv)\/([^/?#]+)\/embed\/?$/i.exec(path);
    if (m) {
      return {
        type: 'INSTA',
        embedUrl: srcAbs,
        openUrl: 'https://www.instagram.com/' + m[1] + '/' + m[2] + '/'
      };
    }
  }
  if (host.endsWith('imgur.com') && /\/embed\/?$/i.test(path)) {
    const open = srcAbs.replace(/\/embed\/?$/i, '');
    return {
      type: 'IMGUR',
      embedUrl: srcAbs,
      openUrl: open
    };
  }
  if (host === 'www.tiktok.com' || host === 'tiktok.com') {
    const ttVideo = /^\/@([^/?#]+)\/video\/(\d+)(?:[/?#]|$)/i.exec(path);
    if (ttVideo) {
      return {
        type: 'TT',
        embedUrl: 'https://www.tiktok.com/player/v1/' + ttVideo[2],
        openUrl: 'https://www.tiktok.com/@' + ttVideo[1] + '/video/' + ttVideo[2]
      };
    }
    const ttPlayer = /^\/(?:embed\/v2|player\/v1)\/(\d+)(?:[/?#]|$)/i.exec(path);
    if (ttPlayer) {
      const id = ttPlayer[1];
      const user = (u.searchParams.get('username') || '').replace(/^@/, '');
      const openUrl = user ? ('https://www.tiktok.com/@' + user + '/video/' + id) : srcAbs;
      return {
        type: 'TT',
        embedUrl: 'https://www.tiktok.com/player/v1/' + id,
        openUrl: openUrl
      };
    }
  }
  return null;
}

function getImgurEmbedFromBlockquote(el) {
  if (!el) return null;
  const dataId = (el.getAttribute('data-id') || '').trim();
  if (!dataId) return null;
  const clean = dataId.replace(/^\//, '');
  const openUrl = 'https://imgur.com/' + clean;
  return { openUrl: openUrl, embedUrl: openUrl + '/embed' };
}

function getYoutubeIdFromItem(item) {
  if (!item) return '';
  const fromEmbed = extractYoutubeIdFromUrl(item.embedUrl || '');
  if (fromEmbed) return fromEmbed;
  const fromUrl = extractYoutubeIdFromUrl(item.url || '');
  if (fromUrl) return fromUrl;
  const fromRaw = extractYoutubeIdFromUrl(item.rawUrl || '');
  if (fromRaw) return fromRaw;
  const fromAbs = extractYoutubeIdFromUrl(item.abs || '');
  if (fromAbs) return fromAbs;
  const fromOpenParsed = extractYoutubeIdFromUrl(item.openUrl || '');
  if (fromOpenParsed) return fromOpenParsed;
  const fromOpen = item.openUrl || '';
  if (fromOpen) {
    const m2 = /[?&]v=([^&?#]+)/i.exec(fromOpen);
    if (m2 && m2[1]) return m2[1];
    const m3 = /\/(?:shorts|live|embed)\/([^/?#&]+)/i.exec(fromOpen);
    if (m3 && m3[1]) return m3[1];
  }
  return '';
}

function getEmbedThumbUrl(item) {
  if (!item || item.kind !== 'embed') return '';
  const t = (item.embedType || '').toUpperCase();
  if (t === 'YT') {
    const id = getYoutubeIdFromItem(item);
    if (id) return 'https://i.ytimg.com/vi/' + id + '/hqdefault.jpg';
    return '';
  }
  if (t === 'X' || t === 'TT' || t === 'INSTA' || t === 'IMGUR') {
    return '';
  }
  return '';
}

function applyEmbedIframeAttrs(iframe, item) {
  iframe.loading = 'lazy';
  iframe.referrerPolicy = 'no-referrer-when-downgrade';
  if (item.embedType === 'X') {
    iframe.setAttribute('sandbox', 'allow-scripts allow-same-origin allow-popups allow-forms');
  } else if (item.embedType === 'YT') {
    iframe.setAttribute('sandbox', 'allow-scripts allow-same-origin allow-popups allow-presentation');
  } else if (item.embedType === 'INSTA') {
    iframe.setAttribute('sandbox', 'allow-scripts allow-same-origin allow-popups');
  } else if (item.embedType === 'TT') {
    iframe.setAttribute('sandbox', 'allow-scripts allow-same-origin allow-popups');
  } else {
    iframe.setAttribute('sandbox', 'allow-scripts allow-popups');
  }
  if (item.embedType === 'YT') {
    iframe.setAttribute('allow', 'accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share');
    iframe.setAttribute('allowfullscreen', 'true');
  } else if (item.embedType === 'TT') {
    iframe.setAttribute('allow', 'autoplay; encrypted-media; picture-in-picture; web-share');
  }
}

function isAutoEmbedItem(item) {
  if (!item || item.kind !== 'embed') return false;
  const src = item.embedUrl || item.url || '';
  if (src) return true;
  return false;
}

function buildEmbedInCard(card, item) {
  if (card.querySelector('iframe')) return;
  if (!item.embedUrl) return;
  const iframe = document.createElement('iframe');
  iframe.className = 'embed';
  iframe.src = item.embedUrl;
  applyEmbedIframeAttrs(iframe, item);
  const thumb = card.querySelector('.thumb');
  if (thumb) {
    thumb.classList.remove('is-playable');
    thumb.innerHTML = '';
    thumb.appendChild(iframe);
  }
}

/* [14] perf */
function queueRender(item) {
  state.items.renderQueue.push(item);
  if (state.items.renderScheduled) return;
  state.items.renderScheduled = true;
  requestAnimationFrame(flushRender);
}

function renderQueueLength() {
  const q = state.items.renderQueue || [];
  const head = state.items.renderQueueHead || 0;
  return Math.max(0, q.length - head);
}

function popRenderQueue() {
  const q = state.items.renderQueue || [];
  const head = state.items.renderQueueHead || 0;
  if (head >= q.length) return null;
  state.items.renderQueueHead = head + 1;
  return q[head];
}

function compactRenderQueue() {
  const q = state.items.renderQueue || [];
  const head = state.items.renderQueueHead || 0;
  if (!q.length || head >= q.length) {
    state.items.renderQueue = [];
    state.items.renderQueueHead = 0;
    return;
  }
  if (head > 64 && head * 2 >= q.length) {
    state.items.renderQueue = q.slice(head);
    state.items.renderQueueHead = 0;
  }
}

function scheduleApplyFilterSort(reason) {
  if (state.items.filterSortTimer) return;
  state.items.filterSortTimer = setTimeout(function() {
    state.items.filterSortTimer = 0;
    applyFilterSort();
  }, 140);
}

function flushRender() {
  state.items.renderScheduled = false;
  const frag = document.createDocumentFragment();
  const newCards = [];
  const limit = Math.min(state.cfg.renderChunk, renderQueueLength());
  for (let i = 0; i < limit; i += 1) {
    const item = popRenderQueue();
    if (!item || item.card) continue;
    const card = createCard(item);
    if (card) {
      frag.appendChild(card);
      newCards.push(card);
    }
  }
  compactRenderQueue();
  state.ui.grid.appendChild(frag);
  if (newCards.length) {
    newCards.forEach(function(card) { observeThumbCard(card); });
    if (state.thumb && !state.thumb.observer && typeof state.thumb.scanNow === 'function') {
      state.thumb.scanNow();
    }
  }
  updateProgress('thumb', state.items.list.length);
  scheduleApplyFilterSort('render');
  if (state.thumb && !state.thumb.observer && typeof state.thumb.scanNow === 'function') {
    state.thumb.scanNow();
  }
  const now = Date.now();
  if (!state.items.lastRenderLog || now - state.items.lastRenderLog > 1200) {
    state.items.lastRenderLog = now;
    state.log.push('render', 'items=' + state.items.list.length + ' visible=' + getVisibleCount() + ' error=' + state.items.errorCount);
  }
  if (renderQueueLength()) {
    requestAnimationFrame(flushRender);
  } else {
    if (state.items.filterSortTimer) {
      clearTimeout(state.items.filterSortTimer);
      state.items.filterSortTimer = 0;
    }
    applyFilterSort();
  }
}

function preconnect() {
  const head = document.head || document.documentElement;
  state.cfg.preconnectHosts.forEach(function(host) {
    if (!host) return;
    const existing = head.querySelector('link[rel="preconnect"][href="' + host + '"]');
    if (existing) return;
    const link = document.createElement('link');
    link.rel = 'preconnect';
    link.href = host;
    link.crossOrigin = '';
    head.appendChild(link);
    const dns = document.createElement('link');
    dns.rel = 'dns-prefetch';
    dns.href = host;
    head.appendChild(dns);
  });
}

/* [15] main */
function getNoiseReasonCode(it) {
  if (!it || !it.__isNoise) return '';
  const reason = it.__noiseReason || '';
  if (reason) return reason;
  const sw = state.cfg.thumbSmallMaxW || 0;
  const sh = state.cfg.thumbSmallMaxH || 0;
  if (sw > 0 && sh > 0 && it.width && it.height && it.width <= sw && it.height <= sh) return 'smallPx';
  if ((it.__thumbScore || 0) >= (state.cfg.thumbLikeMinScore || 0)) return 'thumbScore';
  return 'noise';
}

function getHideReasonCode(it) {
  if (!it) return '';
  if (!passesFilter(it)) return 'filter';
  if (state.cfg.noiseHide && it.__isNoise) return 'noise:' + getNoiseReasonCode(it);
  if (it.__hashDup) return 'dup';
  if (it.__failed) return 'failed';
  if (state.cfg.hiddenHide && it.__allHidden) return 'origHidden';
  if (it.card && it.card.classList.contains('is-hidden')) return 'cardHidden';
  return '';
}

function getHideReasonLabel(code) {
  if (!code) return '';
  if (code === 'filter') return 'フィルタ';
  if (code === 'dup') return '重複';
  if (code === 'failed') return '失敗';
  if (code === 'origHidden') return '元非表示';
  if (code === 'cardHidden') return 'UI非表示';
  if (code.indexOf('noise:') === 0) {
    const sub = code.slice(6);
    if (sub === 'thumbScore') return 'ノイズ(スコア)';
    if (sub === 'smallPx') return 'ノイズ(<=100px)';
    if (sub === 'smallDim') return 'ノイズ(小寸法)';
    if (sub === 'smallArea') return 'ノイズ(小面積)';
    if (sub === 'extremeAspect') return 'ノイズ(極端比率)';
    return 'ノイズ';
  }
  return code;
}

function getHideReasonShort(code) {
  if (!code) return '';
  if (code === 'filter') return 'フィルタ';
  if (code === 'dup') return '重複';
  if (code === 'failed') return '失敗';
  if (code === 'origHidden') return '元非表示';
  if (code === 'cardHidden') return 'UI';
  if (code.indexOf('noise:') === 0) {
    const sub = code.slice(6);
    if (sub === 'thumbScore') return 'score';
    if (sub === 'smallPx') return '<=100';
    if (sub === 'smallDim') return '小寸法';
    if (sub === 'smallArea') return '小面積';
    if (sub === 'extremeAspect') return '比率';
    return 'noise';
  }
  return code;
}

function formatItemMetaText(item) {
  const base = (item && item.width && item.height) ? (item.width + '×' + item.height) : ((item && item.kind) ? item.kind.toUpperCase() : '');
  const parts = [];
  if (item && typeof item.__thumbScore === 'number' && item.__thumbScore > 0) {
    parts.push('TS' + Math.round(item.__thumbScore));
  }
  if (item && Number.isFinite(item.score)) {
    parts.push('S' + Number(item.score).toFixed(1));
  }
  if (item && item.__isNoise) {
    parts.push('H:' + getHideReasonShort('noise:' + getNoiseReasonCode(item)));
  }
  return parts.length ? (base + ' [' + parts.join(' ') + ']') : base;
}

function collectVisibilityStats(limitHidden) {
  const counts = Object.create(null);
  const hidden = [];
  let visible = 0;
  state.items.list.forEach(function(it) {
    const reason = getHideReasonCode(it);
    it.__hideReason = reason;
    if (!reason) {
      visible += 1;
      return;
    }
    counts[reason] = (counts[reason] || 0) + 1;
    if (limitHidden && hidden.length < limitHidden) {
      hidden.push({ item: it, reason: reason });
    }
  });
  return { visible: visible, counts: counts, hidden: hidden };
}

function formatHideReasonCounts(counts, maxEntries) {
  const entries = Object.keys(counts || {}).map(function(k) {
    return [k, counts[k]];
  });
  if (!entries.length) return '';
  entries.sort(function(a, b) {
    if (b[1] !== a[1]) return b[1] - a[1];
    return a[0] < b[0] ? -1 : 1;
  });
  const limit = Math.max(1, maxEntries || entries.length);
  const shown = entries.slice(0, limit).map(function(pair) {
    return getHideReasonShort(pair[0]) + ' ' + pair[1];
  });
  if (entries.length > limit) {
    const rest = entries.slice(limit).reduce(function(acc, pair) { return acc + pair[1]; }, 0);
    shown.push('他 ' + rest);
  }
  return shown.join(' / ');
}

function getHideReasonCountLines(counts, limit) {
  const entries = Object.keys(counts || {}).map(function(k) {
    return [k, counts[k]];
  });
  entries.sort(function(a, b) {
    if (b[1] !== a[1]) return b[1] - a[1];
    return a[0] < b[0] ? -1 : 1;
  });
  const max = Math.max(1, limit || entries.length);
  return entries.slice(0, max).map(function(pair, i) {
    return (i + 1) + '. ' + getHideReasonLabel(pair[0]) + ' (' + pair[0] + '): ' + pair[1];
  });
}

function getItemLogUrl(it) {
  if (!it) return '';
  if (it.kind === 'embed') {
    return (it.url || '') + ' | open=' + (it.openUrl || '');
  }
  return it.url || it.openUrl || it.rawUrl || '';
}

function getHiddenItemsWithReason(limit) {
  const stats = collectVisibilityStats(limit || 0);
  return stats.hidden.map(function(entry, i) {
    const it = entry.item;
    const reason = entry.reason;
    const extras = [];
    if (it && typeof it.__thumbScore === 'number' && it.__thumbScore > 0) extras.push('TS=' + Math.round(it.__thumbScore));
    if (it && it.dupCount >= 2) extras.push('dup=' + it.dupCount);
    if (it && it.__noiseReason) extras.push('nr=' + it.__noiseReason);
    return (i + 1) + '. [' + getHideReasonLabel(reason) + '|' + reason + '] ' + getItemLogUrl(it) + (extras.length ? (' | ' + extras.join(' ')) : '');
  });
}

function isItemVisible(it) {
  const reason = getHideReasonCode(it);
  it.__hideReason = reason;
  return !reason;
}

function getVisibleCount() {
  return collectVisibilityStats(0).visible;
}

function getVisibleItems(limit) {
  const out = [];
  state.items.list.forEach(function(it) {
    if (out.length >= limit) return;
    if (!isItemVisible(it)) return;
    out.push(getItemLogUrl(it));
  });
  return out;
}

function getFailedItems(limit) {
  const out = [];
  state.items.list.forEach(function(it) {
    if (out.length >= limit) return;
    if (!it.__failed) return;
    out.push(it.url || it.openUrl || it.rawUrl || '');
  });
  return out.filter(Boolean);
}

function updateInfo() {
  if (!state.ui.info) return;
  if (state.ui.infoTimer) return;
  const now = Date.now();
  const minGap = 180;
  const stats = collectVisibilityStats(0);
  const visible = stats.visible;
  const reasonText = formatHideReasonCounts(stats.counts, 4);
  const text = `表示 ${visible} / 全体 ${state.items.list.length} / エラー ${state.items.errorCount}${reasonText ? ' / 非表示 ' + reasonText : ''}`;
  const elapsed = now - (state.ui.infoLastAt || 0);
  if (elapsed < minGap) {
    if (text === state.ui.infoLastText) return;
    if (state.ui.infoThrottleTimer) clearTimeout(state.ui.infoThrottleTimer);
    state.ui.infoPendingText = text;
    state.ui.infoThrottleTimer = setTimeout(function() {
      state.ui.infoThrottleTimer = 0;
      if (!state.ui.info || state.ui.infoTimer) return;
      const pending = state.ui.infoPendingText;
      state.ui.infoPendingText = '';
      if (!pending) return;
      state.ui.info.textContent = pending;
      const at = Date.now();
      state.ui.infoLastAt = at;
      state.ui.infoLastText = pending;
    }, minGap - elapsed);
    return;
  }
  if (state.ui.infoThrottleTimer) {
    clearTimeout(state.ui.infoThrottleTimer);
    state.ui.infoThrottleTimer = 0;
  }
  state.ui.infoPendingText = '';
  state.ui.info.textContent = text;
  state.ui.infoLastAt = now;
  state.ui.infoLastText = text;
}

function updateProgress(phase, token) {
  if (!state.ui.progress) return;
  const now = Date.now();
  const minGap = 100;
  const t = token ? String(token) : '';
  const text = `${phase}${t ? ' ' + t : ''}`;
  const phaseChanged = phase !== state.ui.progressLastPhase;
  const elapsed = now - (state.ui.progressLastAt || 0);
  if (!phaseChanged && elapsed < minGap) {
    if (text === state.ui.progressLastText) return;
    if (state.ui.progressThrottleTimer) clearTimeout(state.ui.progressThrottleTimer);
    state.ui.progressPendingPhase = phase;
    state.ui.progressPendingText = text;
    state.ui.progressThrottleTimer = setTimeout(function() {
      state.ui.progressThrottleTimer = 0;
      if (!state.ui.progress) return;
      const pendingText = state.ui.progressPendingText;
      const pendingPhase = state.ui.progressPendingPhase;
      state.ui.progressPendingText = '';
      state.ui.progressPendingPhase = '';
      if (!pendingText) return;
      state.ui.progress.textContent = pendingText;
      const at = Date.now();
      state.ui.progressLast = at;
      state.ui.progressLastAt = at;
      state.ui.progressLastText = pendingText;
      state.ui.progressLastPhase = pendingPhase || '';
    }, minGap - elapsed);
    return;
  }
  if (state.ui.progressThrottleTimer) {
    clearTimeout(state.ui.progressThrottleTimer);
    state.ui.progressThrottleTimer = 0;
  }
  state.ui.progressPendingText = '';
  state.ui.progressPendingPhase = '';
  state.ui.progress.textContent = text;
  state.ui.progressLast = now;
  state.ui.progressLastAt = now;
  state.ui.progressLastText = text;
  state.ui.progressLastPhase = phase || '';
}

function setInfoTemp(message, ms) {
  if (!state.ui.info) return;
  if (state.ui.infoThrottleTimer) {
    clearTimeout(state.ui.infoThrottleTimer);
    state.ui.infoThrottleTimer = 0;
  }
  state.ui.infoPendingText = '';
  if (state.ui.infoTimer) clearTimeout(state.ui.infoTimer);
  state.ui.info.textContent = message;
  state.ui.infoTimer = setTimeout(function() {
    state.ui.infoTimer = 0;
    updateInfo();
  }, ms || 1200);
}

function flashLogButton() {
  const btn = state.ui.logBtn;
  if (!btn) return;
  const base = btn.textContent;
  btn.textContent = 'コピー済';
  setTimeout(function() {
    if (btn) btn.textContent = base;
  }, 800);
}

function showCopyModal(text) {
  const wrap = state.ui.wrap;
  if (!wrap) return;
  const existing = wrap.querySelector('.copy-modal');
  if (existing) existing.parentNode.removeChild(existing);
  const modal = document.createElement('div');
  modal.className = 'copy-modal';
  modal.style.position = 'fixed';
  modal.style.inset = '0';
  modal.style.display = 'flex';
  modal.style.alignItems = 'center';
  modal.style.justifyContent = 'center';
  modal.style.background = 'rgba(0,0,0,0.6)';
  modal.style.zIndex = '2147483647';
  const box = document.createElement('div');
  box.style.width = '90vw';
  box.style.maxWidth = '720px';
  box.style.background = '#111';
  box.style.border = '1px solid #444';
  box.style.borderRadius = '14px';
  box.style.padding = '12px';
  box.style.color = '#eee';
  const label = document.createElement('div');
  label.textContent = '長押しでコピー';
  label.style.fontSize = '12px';
  label.style.marginBottom = '8px';
  const ta = document.createElement('textarea');
  ta.value = text;
  ta.readOnly = true;
  ta.style.width = '100%';
  ta.style.height = '40vh';
  ta.style.background = '#0b0b0b';
  ta.style.color = '#eee';
  ta.style.border = '1px solid #333';
  ta.style.borderRadius = '10px';
  ta.style.padding = '8px';
  const closeBtn = document.createElement('button');
  closeBtn.textContent = '閉じる';
  closeBtn.style.marginTop = '10px';
  closeBtn.style.padding = '8px 14px';
  closeBtn.style.borderRadius = '999px';
  closeBtn.style.border = '1px solid #555';
  closeBtn.style.background = '#fff';
  closeBtn.style.color = '#111';
  closeBtn.addEventListener('click', function() {
    if (modal.parentNode) modal.parentNode.removeChild(modal);
  });
  box.appendChild(label);
  box.appendChild(ta);
  box.appendChild(closeBtn);
  modal.appendChild(box);
  wrap.appendChild(modal);
  setTimeout(function() {
    try {
      ta.focus();
      ta.select();
    } catch (e) {}
  }, 50);
  setInfoTemp('コピー用モーダルを表示', 1400);
}

function applyErrorVis() {
  updateInfo();
}

function allowOpen(url) {
  try {
    const u = new URL(url, location.href);
    if (!(u.protocol === 'http:' || u.protocol === 'https:')) return false;
    const abs = u.toString();
    if (sameSite(abs)) return true;
    if (isImageUrl(abs) || isVideoUrl(abs)) return true;
    const host = u.hostname.toLowerCase();
    const allow = [
      'x.com',
      'twitter.com',
      'instagram.com',
      'tiktok.com',
      'imgur.com',
      'youtube.com',
      'youtu.be',
      'ytimg.com',
      'twimg.com',
      'pbs.twimg.com',
      'video.twimg.com',
      'i.imgur.com',
      'i.ytimg.com'
    ];
    for (let i = 0; i < allow.length; i += 1) {
      const h = allow[i];
      if (host === h || host.endsWith('.' + h)) return true;
    }
    return false;
  } catch (e) {
    return false;
  }
}

function openExternal(url, from) {
  if (!allowOpen(url)) return false;
  let w = null;
  try {
    w = window.open(url, '_blank', 'noopener,noreferrer');
  } catch (e) {}
  if (w) return true;
  try {
    const p = copyText(String(url));
    if (p && typeof p.then === 'function') {
      p.then(function(ok) {
        setInfoTemp(ok ? 'URLコピー' : 'URL準備', 1400);
      }).catch(function() {
        setInfoTemp('URL準備', 1400);
      });
    } else {
      setInfoTemp('URL準備', 1400);
    }
  } catch (e) {
    setInfoTemp('URL準備', 1400);
  }
  return false;
}

function safeCompletion(status, detail) {
  try {
    if (typeof window.completion === 'function') window.completion(status, detail);
  } catch (e) {}
}

async function copyText(text) {
  if (navigator.clipboard && navigator.clipboard.writeText) {
    try {
      await navigator.clipboard.writeText(text);
      return true;
    } catch (e) {}
  }
  let ta = null;
  try {
    ta = document.createElement('textarea');
    ta.value = text;
    ta.setAttribute('readonly', '');
    ta.style.position = 'fixed';
    ta.style.left = '-9999px';
    ta.style.top = '0';
    const host = document.body || document.documentElement;
    if (!host) return false;
    host.appendChild(ta);
    ta.focus();
    ta.select();
    const ok = document.execCommand('copy');
    host.removeChild(ta);
    if (ok) return true;
  } catch (e) {
    if (ta && ta.parentNode) ta.parentNode.removeChild(ta);
  }
  if (navigator.share) {
    try {
      await navigator.share({ text: text });
      return true;
    } catch (e) {}
  }
  showCopyModal(text);
  return false;
}

function uniq(list) {
  const out = [];
  const seen = new Set();
  list.forEach(function(v) {
    if (!v || seen.has(v)) return;
    seen.add(v);
    out.push(v);
  });
  return out;
}

function forceRepaintImage(img, restoreList) {
  if (!img || !img.isConnected) return;
  if (!state.env || !state.env.isIOS) return;
  let useFallback = false;
  try {
    const marked = img.dataset ? img.dataset.fmpRepaintFallback : img.getAttribute('data-fmp-repaint-fallback');
    if (marked !== '1') {
      useFallback = true;
      if (img.dataset) img.dataset.fmpRepaintFallback = '1';
      else img.setAttribute('data-fmp-repaint-fallback', '1');
    }
  } catch (e) {}
  try {
    const prevWillChange = img.style.willChange;
    const prevTransform = img.style.transform;
    const prevWebkitTransform = img.style.webkitTransform;
    const prevBackface = img.style.backfaceVisibility;
    const prevWebkitBackface = img.style.webkitBackfaceVisibility;
    img.style.willChange = 'opacity, transform';
    img.style.transform = 'translateZ(0)';
    img.style.webkitTransform = 'translateZ(0)';
    img.style.backfaceVisibility = 'hidden';
    img.style.webkitBackfaceVisibility = 'hidden';
    if (useFallback) {
      try {
        img.style.transform = 'translate3d(0,0,0)';
        img.style.webkitTransform = 'translate3d(0,0,0)';
      } catch (e) {}
    }
    const restore = function() {
      try {
        img.style.willChange = prevWillChange;
        img.style.transform = prevTransform;
        img.style.webkitTransform = prevWebkitTransform;
        img.style.backfaceVisibility = prevBackface;
        img.style.webkitBackfaceVisibility = prevWebkitBackface;
      } catch (e) {}
    };
    if (restoreList && typeof restoreList.push === 'function') restoreList.push(restore);
    else requestAnimationFrame(restore);
  } catch (e) {}
}

function isProbablyImageUrl(url) {
  if (!url) return false;
  if (/^(data:|blob:)/i.test(url)) return true;
  return /\.(avif|webp|png|gif|jpe?g|bmp|svg)(\?|#|$)/i.test(url);
}

function isSameImageVariantUrl(a, b) {
  if (!a || !b) return false;
  if (isSameLoadedSrc(a, b)) return true;
  const ka = canonicalMediaKey(a, 'img');
  const kb = canonicalMediaKey(b, 'img');
  return !!(ka && kb && ka === kb);
}

function getDisplayUrl(item) {
  if (!item || item.kind !== 'img') return item ? item.url : '';
  if (item.openUrl && isProbablyImageUrl(item.openUrl)) {
    if (item.url && isSameImageVariantUrl(item.openUrl, item.url)) return item.url;
    return item.openUrl;
  }
  return item.url;
}

function decodeWithTimeout(img, ms) {
  if (!img || typeof img.decode !== 'function') return Promise.resolve(false);
  const timeoutMs = typeof ms === 'number' ? ms : 0;
  let settled = false;
  return new Promise(function(resolve) {
    const t = setTimeout(function() {
      if (settled) return;
      settled = true;
      resolve(false);
    }, timeoutMs);
    img.decode().then(function() {
      if (settled) return;
      settled = true;
      clearTimeout(t);
      resolve(true);
    }).catch(function() {
      if (settled) return;
      settled = true;
      clearTimeout(t);
      resolve(false);
    });
  });
}

function sleep(ms) {
  return new Promise(function(resolve) { setTimeout(resolve, ms); });
}

function markThumbProgress() {
  if (!state.wd) return;
  state.wd.thumbLastProgressAt = Date.now();
  const inflight = state.thumb ? state.thumb.inFlight : 0;
  const queued = thumbQueueLength();
  state.wd.thumbLastProgressCount = inflight + queued;
}

function markLbProgress(token) {
  if (!state.wd) return;
  state.wd.lbLastProgressAt = Date.now();
  if (token) state.wd.lbLastToken = token;
}

function startWatchdog() {
  if (!state.cfg || !state.cfg.wdEnabled) return;
  if (!state.wd || state.wd.running) return;
  state.wd.running = true;
  if (!state.wd.thumbLastProgressAt) markThumbProgress();
  if (!state.wd.lbLastProgressAt) state.wd.lbLastProgressAt = Date.now();
  const loop = function() {
    if (!state.wd.running) return;
    tickWatchdog();
    state.wd.t = setTimeout(loop, state.cfg.wdTickMs || 1200);
  };
  loop();
}

function stopWatchdog() {
  if (!state.wd) return;
  state.wd.running = false;
  if (state.wd.t) {
    clearTimeout(state.wd.t);
    state.wd.t = 0;
  }
}

function pickStuckThumbCandidate(now, stallMs) {
  const list = state.items && state.items.list ? state.items.list : [];
  if (!list.length) return null;
  const maxKick = state.cfg.wdMaxKickThumb || 0;
  const preferVisible = list.length >= (state.cfg.wdMinItemsForThrottle || 0);
  const vh = window.innerHeight || (document.documentElement && document.documentElement.clientHeight) || 0;
  let best = null;
  let bestScore = Infinity;
  let bestAge = -1;
  for (let i = 0; i < list.length; i += 1) {
    const item = list[i];
    if (!item || !item.__thumbLoading || !item.__thumbCtx || typeof item.__thumbCtx.abort !== 'function') continue;
    if (item.__failed || item.__thumbLoaded) continue;
    const cnt = state.wd.thumbKickMap.get(item.id) || 0;
    if (maxKick && cnt >= maxKick) continue;
    const startedAt = item.__thumbStartedAt || 0;
    if (stallMs && startedAt && now - startedAt < stallMs) continue;
    if (preferVisible) {
      let score = 999999;
      if (item.card && typeof item.card.getBoundingClientRect === 'function') {
        const r = item.card.getBoundingClientRect();
        const visible = r.bottom >= 0 && r.top <= vh;
        if (visible) score = 0;
        else score = Math.min(Math.abs(r.top), Math.abs(r.bottom - vh));
      }
      if (score < bestScore) {
        bestScore = score;
        best = item;
      }
    } else {
      const age = startedAt ? (now - startedAt) : (now + 1);
      if (age > bestAge) {
        bestAge = age;
        best = item;
      } else if (!best) {
        best = item;
      }
    }
  }
  return best;
}

function tickWatchdog() {
  if (!state.cfg || !state.cfg.wdEnabled) return;
  if (!state.wd) return;
  const now = Date.now();
  state.wd.lastTick = now;

  if (state.thumb && (state.thumb.inFlight > 0 || thumbQueueLength() > 0)) {
    const stallMs = state.cfg.wdStallMsThumb || 0;
    const last = state.wd.thumbLastProgressAt || 0;
    if (stallMs && last && (now - last > stallMs)) {
      const item = pickStuckThumbCandidate(now, stallMs);
      if (item) {
        const cnt = state.wd.thumbKickMap.get(item.id) || 0;
        const maxKick = state.cfg.wdMaxKickThumb || 0;
        if (!maxKick || cnt < maxKick) {
          try {
            if (item.__thumbCtx && typeof item.__thumbCtx.abort === 'function') {
              item.__thumbCtx.abort('watchdog');
            }
          } catch (e) {}
          item.__thumbLoading = false;
          item.__thumbCtx = null;
          if (item.card) showThumbOverlay(item.card, 'LOADING');
          thumbEnqueue(item);
          state.wd.thumbKickMap.set(item.id, cnt + 1);
          markThumbProgress();
          if (state.cfg.wdLog && state.log && state.log.push) {
            state.log.push('wd', 'thumb kick id=' + item.id + ' cnt=' + (cnt + 1) + ' inFlight=' + state.thumb.inFlight + ' q=' + thumbQueueLength());
          }
        }
      }
    }
  }

  if (state.lb && state.lb.open && state.lb.__loading) {
    const stallMs = state.cfg.wdStallMsLb || 0;
    const last = state.wd.lbLastProgressAt || 0;
    if (stallMs && last && (now - last > stallMs)) {
      const maxKick = state.cfg.wdMaxKickLb || 0;
      if (!maxKick || state.wd.lbKickCount < maxKick) {
        try {
          if (state.lb.__ctx && typeof state.lb.__ctx.abort === 'function') {
            state.lb.__ctx.abort('watchdog');
          }
        } catch (e) {}
        if (state.lb.__ctx && typeof state.lb.__ctx.retry === 'function') {
          state.lb.__ctx.retry();
        } else {
          renderLightboxItem();
        }
        state.wd.lbKickCount += 1;
        markLbProgress(state.lb.__token);
        if (state.cfg.wdLog && state.log && state.log.push) {
          state.log.push('wd', 'lb kick cnt=' + state.wd.lbKickCount);
        }
      }
    }
  }
}

function disconnectMutationObserver() {
  if (!state.mo) return;
  if (state.mo.t) {
    clearTimeout(state.mo.t);
    state.mo.t = 0;
  }
  if (state.mo.obs) {
    try { state.mo.obs.disconnect(); } catch (e) {}
    state.mo.obs = null;
  }
  state.mo.pending = false;
  state.mo.dirty = false;
}

function scheduleDomRescan(reason) {
  if (!state.cfg || !state.cfg.moEnabled) return;
  if (!state.mo) return;
  state.mo.dirty = true;
  state.mo.lastReason = reason || 'mo';
  if (state.mo.pending) return;
  state.mo.pending = true;
  if (state.mo.t) clearTimeout(state.mo.t);
  state.mo.t = setTimeout(function() {
    state.mo.t = 0;
    const now = Date.now();
    const cooldown = state.cfg.moCooldownMs || 0;
    const since = now - (state.mo.lastRun || 0);
    if (cooldown && since < cooldown) {
      const wait = cooldown - since;
      state.mo.t = setTimeout(function() {
        state.mo.t = 0;
        if (!state.mo.pending) return;
        state.mo.lastRun = Date.now();
        state.mo.pending = false;
        state.mo.dirty = false;
        runDomRescanOnce('mo:' + (state.mo.lastReason || 'mo'));
      }, wait);
      return;
    }
    state.mo.lastRun = now;
    state.mo.pending = false;
    state.mo.dirty = false;
    runDomRescanOnce('mo:' + (state.mo.lastReason || 'mo'));
  }, state.cfg.moDebounceMs || 0);
}

function runDomRescanOnce(reason) {
  if (state.abort && state.abort.aborted) return;
  const before = state.items.list.length;
  addItems(extractFromDocument(document, 'dom', location.href));
  const after = state.items.list.length;
  const added = after - before;
  if (state.log && state.log.push) {
    state.log.push('mo', 'rescan dom reason=' + (reason || '') + ' added=+' + added + ' total=' + after);
  }
  updateInfo();
}

function setupMutationObserver() {
  if (!state.cfg || !state.cfg.moEnabled) return;
  if (!state.mo) return;
  if (state.mo.obs) return;
  if (typeof MutationObserver !== 'function') return;
  const target = document.body;
  if (!target) return;
  const reasonFromTag = function(tag) {
    if (!tag) return '';
    const t = tag.toUpperCase();
    if (t === 'IMG' || t === 'PICTURE' || t === 'SOURCE') return 'added-img';
    if (t === 'VIDEO') return 'added-video';
    if (t === 'A') return 'added-a';
    if (t === 'IFRAME' || t === 'BLOCKQUOTE') return 'added-embed';
    return '';
  };
  const findReasonFromNode = function(node) {
    if (!node || node.nodeType !== 1) return '';
    const direct = reasonFromTag(node.tagName);
    if (direct) return direct;
    if (!node.querySelector || !node.childElementCount) return '';
    try {
      const hit = node.querySelector('img,picture,source,video,a,iframe,blockquote');
      if (hit && hit.tagName) return reasonFromTag(hit.tagName) || 'added-child';
    } catch (e) {}
    return '';
  };
  try {
    state.mo.obs = new MutationObserver(function(mutations) {
      if (!mutations || !mutations.length) return;
      const maxMut = state.cfg.moMaxMutations || 0;
      if (maxMut && mutations.length > maxMut) {
        scheduleDomRescan('burst');
        return;
      }
      let reason = '';
      for (let i = 0; i < mutations.length; i += 1) {
        const m = mutations[i];
        if (m.type === 'childList') {
          const nodes = m.addedNodes || [];
          for (let j = 0; j < nodes.length; j += 1) {
            const r = findReasonFromNode(nodes[j]);
            if (r) {
              reason = r;
              break;
            }
          }
        } else if (m.type === 'attributes') {
          const name = m.attributeName || '';
          const t = m.target;
          if (t && t.nodeType === 1) {
            const tr = reasonFromTag(t.tagName);
            if (tr && name) {
              reason = 'attr-' + name;
            }
          }
        }
        if (reason) break;
      }
      if (reason) scheduleDomRescan(reason);
    });
    state.mo.obs.observe(target, {
      childList: true,
      subtree: true,
      attributes: !!state.cfg.moObserveAttributes,
      attributeFilter: state.cfg.moAttrFilter || undefined
    });
  } catch (e) {
    state.mo.obs = null;
  }
}

function maybeFinalize() {
  if (finalizeOnce) return;
  if (state.crawl.started && !state.crawl.done) return;
  finalize('ok', { items: state.items.list.length, errors: state.items.errorCount });
}

async function main() {
  try {
    guardAndCleanup();
    initEnv();
    initCfg();
    initLogger();
    state.log.push('boot', 'href=' + state.env.href + ' host=' + state.env.host + ' ua=' + state.env.ua);
    state.log.push('device', 'iphone=' + state.env.isIPhone + ' ipad=' + state.env.isIPad);
    createShell();
    mountShell(0);
    (function waitForUiLock(tries) {
      if (isUiVisible(state)) {
        lockPage(state);
        return;
      }
      if (tries < 12) {
        requestAnimationFrame(function() { waitForUiLock(tries + 1); });
      }
    })(0);
    setTimeout(function() {
      if (isUiVisible(state)) {
        lockPage(state);
        return;
      }
      unlockPage(state);
      cleanupUi();
      showBootBadgeGlobal('panel not visible (scroll restored)');
    }, 800);

    window.__FMP_ABORT__ = state.abort;
    window.__FMP_ABORT_CONTROLLERS__ = state.abort.controllers;
    window.__FMP_ITEMS__ = state.items.list;
    window.__FMP_SEEN__ = state.seen.map;
    window.__FMP_SEEN_ORDER__ = state.seen.order;
    window.__FMP_GROUP_BEST__ = state.groupBest;
    window.__FMP_FILTER__ = state.filter;
    window.__FMP_SORT__ = state.sort;
    window.__FMP_STOP_CRAWL__ = abortAll;
    window.__FMP_SET_FILTER__ = setFilter;
    window.__FMP_APPLY_FILTER_SORT__ = applyFilterSort;
    window.__FMP_APPLY_ERROR_VIS__ = applyErrorVis;
    window.__FMP_LB_OPEN__ = function(idOrIndex) {
      if (typeof idOrIndex === 'number') {
        buildLightboxList();
        if (idOrIndex >= 0 && idOrIndex < state.lb.list.length) {
          state.lb.index = idOrIndex;
          renderLightboxItem();
          state.lb.overlay.classList.add('open');
          state.lb.open = true;
          if (state.thumb) state.thumb.paused = true;
        }
      } else if (typeof idOrIndex === 'string') {
        openLightboxById(idOrIndex);
      }
    };
    if (typeof window.__FMP_ON_LB_CLOSE__ === 'undefined') window.__FMP_ON_LB_CLOSE__ = null;

    createLightbox();
    bindVisibilityHandlers();
    preconnect();

    await collectInitial();
    state.log.push('collect', 'done total=' + state.items.list.length);
    applyFilterSort();
    updateInfo();
    setupMutationObserver();
    startWatchdog();

    const needByCount = state.items.list.length < state.cfg.htmlMinItems;
    const bodyLinks = countBodySameOriginLinks(document, location.href);
    const imgCount = countImageCandidates();
    const linkCandidates = collectCrawlLinksFromDocument(document, location.href);
    const pagerPlan = buildPagerPlan(location.href, document);
    const hasLinks = linkCandidates.length > 0;
    const mediaDoc = isMediaDocument(document);
    const lightCrawl = hasLinks && !mediaDoc;
    const preBoostImgLimit = Math.max((state.cfg.htmlMinItems || 0) * 4, 80);
    const shouldPreBoost = (
      !mediaDoc &&
      hasLinks &&
      !state.crawl.allowUserBoost &&
      linkCandidates.length >= (state.cfg.crawlBaseLimit * 4) &&
      bodyLinks >= state.cfg.crawlBaseLimit &&
      imgCount < preBoostImgLimit
    );
    if (shouldPreBoost) {
      state.crawl.allowUserBoost = true;
      state.log.push('crawl', 'pre-boost links=' + linkCandidates.length + ' bodyLinks=' + bodyLinks + ' img=' + imgCount + ' limit=' + (state.cfg.crawlBaseLimit + state.cfg.crawlBoost));
    }
    if (!mediaDoc && (needByCount || lightCrawl || imgCount < 12 || (pagerPlan && pagerPlan.urls && pagerPlan.urls.length))) {
      const delay = needByCount ? 0 : 120;
      state.log.push('crawl', 'trigger need=' + needByCount + ' links=' + linkCandidates.length + ' bodyLinks=' + bodyLinks + ' img=' + imgCount + ' pager=' + (pagerPlan && pagerPlan.urls ? pagerPlan.urls.length : 0));
      if (state.crawl.timer) clearTimeout(state.crawl.timer);
      state.crawl.timer = setTimeout(function() { state.crawl.timer = 0; startCrawl(); }, delay);
    } else {
      state.crawl.done = true;
      updateProgress('idle', 'ready');
      maybeFinalize();
    }
  } catch (e) {
    const msg = e && e.message ? e.message : String(e);
    if (state.ui && state.ui.info) {
      if (state.ui.infoTimer) {
        clearTimeout(state.ui.infoTimer);
        state.ui.infoTimer = 0;
      }
      state.ui.info.textContent = 'fatal: ' + msg;
    }
    if (state.ui && state.ui.progress) {
      updateProgress('fatal', 'main');
    }
    if (state.log && state.log.push) state.log.push('error', msg);
    finalize('error', { message: msg, phase: 'main' });
  }
}

main();

/*
[acceptance tests]
1) タップしたサムネがLBで同一画像として開く（別画像NG）
2) Prev/Next/Close が常に反応
3) Filter BODY/IMG/ALL が期待どおり
4) Sort SIZE が期待どおり
5) 巡回停止でネット取得が止まる（Abort）
6) load error はinfoに件数のみ、カードは非表示
7) weekly.ascii.jp img.html 救済が効く（DOM0件でも拾える）
8) 背景が完全に黒基調になっている
9) global.toyota のようなページで「細い横線だらけ」にならない（ノイズが抑制される）
10) ALLダブルタップでノイズ表示ON/OFFが切り替わる
11) ログコピーがiOS/SFSafariViewでも成功しやすい（失敗時も理由が出る）
12) iPhoneでLB操作がドック寄せ、iPadは全体縮小＋LBボタンだけ大きめ
A) iPadで実行しても必ずパネルが出る（Shadow DOM不可でもLight DOMで出る）
B) 取得が進んでもカード/サムネ高さが維持され、潰れていかない
C) .grid がスクロールで安定して動作する（flex潰れなし）
16) 拡張子なし画像（image?id=...）が拾える
17) ログコピーは clipboard不可でも share/モーダルで必ず回収できる
18) 「閉じる」後に元ページのスクロールが必ず復旧する
19) poster無しの動画でもLightboxで再生できる（サムネ生成が失敗しても再生優先）
20) UI表示直後でも「ログコピー」が必ず反応する
21) iPadでパネルが出ない場合でもスクロールが殺されない（800ms後に復旧）
22) “ロック残り”があっても再実行で必ず復旧する
23) iPhoneのLB操作ボタン群が左寄せになり左手で押しやすい
24) iPadでUI内部が描画されていない場合、スクロールもタップも奪わない（pointer-events段階制御）
25) 800ms失敗時はUIが撤去され、元ページが完全に操作可能
26) aタグ無しのX埋め込み（platform.twitter.com iframe）でも一覧に X が出る
27) aタグ無しのImgur埋め込み（blockquote data-id）でも一覧に IMGUR が出る
28) x.com/i/web/status/ のリンクでも X として判定される
29) X/IMGUR item をタップ → Lightboxが開き、LOADで埋め込み表示できる
30) embedでも Prev/Next/Close が常に反応
31) embedカードのinline展開（metaのINボタン）も従来どおり動く（機能保持）
32) pbs.twimg.com の name/format違いが1枚に統合される（重複が減る）
33) i.imgur.com のサイズサフィックス違い（m/l等）が1枚に統合される
34) iPadでもLightboxのPrev/Next/Closeが左寄せになり左手で押しやすい
35) ↗（カード/Lightbox）後でもLBが操作不能にならない（新規タブ成功時はUI維持、失敗時はUI撤去して遷移）
36) 一覧サムネは contain で枠内表示、かつ小画像は拡大しない
37) livedoor系で「Xと動画だけ」にならず、エラーでもカードが残り原因が見える
38) ログコピーが (empty) にならない（サマリ＋URLが取れる）
39) ↗ を押した後も Lightbox の Prev/Next/Close が反応し続ける
40) itemsが22以上でも、リンク先本体型ページで巡回が動き追加で拾える
41) 次ページ（rel=next）を辿れて取り漏れが減る
42) 巡回停止でinFlightが止まり、以降キューが進まない
43) embedはLBでLOADボタン無しで自動表示される
44) embedの表示失敗時はLBバッジにEMBED FAILが出る
45) livedoor系で“Xと動画だけ残る”にならず、失敗カードも残って原因が見える
46) ログコピーが (empty) にならない（サマリ+URLが出る）
47) LBでPrev/Next後にCloseすると一覧スクロールが該当カードへ追従する
48) 本文外のロゴ/アイコンが拾われない（ナビ/ヘッダ/フッタ由来が減る）
49) img load error のカードは一覧に残らない（表示から除外される）
50) X/IMGUR/TT/INSTA/YTはLBでLOAD無し自動表示
51) 同一originリンクがあるページでは軽巡回が必ず走り、停止で完全停止する
52) log.copy は (empty) にならず、サマリ＋URLが取得できる
53) 表示対象が少なくても progress に 'script' / 'html' が出ない
54) 本文外の余計なアイコン/ロゴ拾いが増えない（本文スコープのみで完結）
55) 取得失敗（img error）したカードは一覧から消える（rev1.20仕様維持）
56) 巡回/停止/ログコピー/LB追従は従来通り動く（回帰なし）
57) livedoor記事で p=2..最終まで巡回し、最終ページ由来の画像も一覧に出る
58) 各カードに P1/P2... のラベルが出て取得元ページが分かる
59) 巡回fetchのHTML文字列復旧拾いが無効化され、本文外混入が増えない
60) 巡回停止でin-flight/タイマーが止まる（回帰なし）
*/

})();
